<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-单调栈" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/11/%E5%8D%95%E8%B0%83%E6%A0%88/" class="article-date">
  <time datetime="2020-06-11T03:59:44.000Z" itemprop="datePublished">2020-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/11/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一-背包、栈、队列"><a href="#一-背包、栈、队列" class="headerlink" title="一 背包、栈、队列"></a>一 背包、栈、队列</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><h3 id="1-背包"><a href="#1-背包" class="headerlink" title="1. 背包"></a>1. 背包</h3><p>​      背包bag是一种不支持从中删除元素的集合数据类型，其目的就是帮助用例收集元素并迭代遍历所有收集到的元素。</p>
<h3 id="2-FIFO队列"><a href="#2-FIFO队列" class="headerlink" title="2. FIFO队列"></a>2. FIFO队列</h3><p>​    元素的处理顺序就是他们被添加到队列中的顺序。</p>
<h3 id="3-下压栈"><a href="#3-下压栈" class="headerlink" title="3.下压栈"></a>3.下压栈</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/11/%E5%8D%95%E8%B0%83%E6%A0%88/" data-id="ckbf7sdeb00001cl5bh57gsm7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95-%E6%A0%88/" rel="tag">算法,栈</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode每日一题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/25/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" class="article-date">
  <time datetime="2020-05-25T11:56:04.000Z" itemprop="datePublished">2020-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/25/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">LeetCode每日一题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="LettCode每日一题-Java"><a href="#LettCode每日一题-Java" class="headerlink" title="LettCode每日一题/Java"></a>LettCode每日一题/Java</h1><blockquote>
<p>题目链接，代码，讲解思路，附带Java知识点</p>
</blockquote>
<h2 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h2><h3 id="2020-05-25"><a href="#2020-05-25" class="headerlink" title="2020/05/25"></a>2020/05/25</h3><ol>
<li><p>2020/05/25<a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">题目描述</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;Integer, Integer&gt;();</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Integer tmp  = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">			tmp = map.get(key);</span><br><span class="line">			map.remove(key);</span><br><span class="line">			map.put(key, tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key)) &#123;</span><br><span class="line">			map.remove(key);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( capacity == <span class="number">0</span> ) &#123;</span><br><span class="line">			Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">			iterator.next();</span><br><span class="line">			iterator.remove();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			capacity--;</span><br><span class="line">		&#125;</span><br><span class="line">		map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li>思路讲解</li>
</ol>
<p><a href="https://blog.csdn.net/justloveyou_/article/details/71713781" target="_blank" rel="noopener">链接</a></p>
<h2 id="六月-0602-0607"><a href="#六月-0602-0607" class="headerlink" title="六月 0602-0607"></a>六月 0602-0607</h2><h3 id="20200-06-02"><a href="#20200-06-02" class="headerlink" title="20200/06/02"></a>20200/06/02</h3><ol>
<li><p>2020/03/02题目：<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>
<ol>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode resetHead = <span class="keyword">null</span>;</span><br><span class="line">		ListNode currentNode = head;</span><br><span class="line">        ListNode tempNode = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span>( currentNode!= <span class="keyword">null</span> ) &#123;</span><br><span class="line">			tempNode = currentNode.next;</span><br><span class="line">			currentNode.next = resetHead; <span class="comment">//指向反向</span></span><br><span class="line">			resetHead = currentNode;  <span class="comment">//“头部”移动</span></span><br><span class="line">			currentNode = tempNode;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resetHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<p>​     要求将 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL实现反转5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL，想法是可以通过简单的将链表指向反转，即使用两个指针，一个指向当前所在节点A,另一个指向前一个节点B，原本A-&gt;B，可以变成B-&gt;A，接着移动节点。</p>
</li>
<li><p>时间复杂度O(1),空间复杂度O(n)</p>
</li>
</ol>
</li>
<li><p>2020/06/02题目：<a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof/</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = n;</span><br><span class="line">		<span class="keyword">boolean</span> flag = n &gt; <span class="number">0</span> &amp;&amp; (sum += sumNums(n-<span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：不可使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句实现数加，则通过&amp;&amp;操作来完成判断操作(不一定成立)和求和操作(添加必成立条件)。</p>
<p>Java在使用逻辑操作符的时候，存在一种短路现象，即一旦可以确定整个表达式的值，就不会再接着计算剩余的部分，如testA()&amp;&amp;testB(),当testA()返回值为true时，会接着计算testB()的值；当testA()返回false时，整个算式的值已经确定，testB()不执行，应用这样的机制来实现题目中隐含的条件判断。所以&amp;&amp;称为短路与，||称为长路与</p>
</li>
</ol>
</li>
</ol>
<h3 id="2020-06-03"><a href="#2020-06-03" class="headerlink" title="2020/06/03"></a>2020/06/03</h3><ol>
<li><p>题目：<a href="https://leetcode-cn.com/problems/new-21-game/动态规划题" target="_blank" rel="noopener">https://leetcode-cn.com/problems/new-21-game/动态规划题</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] dp = <span class="keyword">new</span> <span class="keyword">double</span>[K+W];</span><br><span class="line">		<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (K + W &lt;= N) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i = K ; i &lt;= N ; i++ ) &#123;</span><br><span class="line">			dp[i] = <span class="number">1</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = K ; i&lt; K + W ; i++) &#123;</span><br><span class="line">			sum += dp[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i = K-<span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">			dp[i] = sum / W;</span><br><span class="line">			sum = sum - dp[i+W] + dp[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<ol>
<li>定义数组元素的含义，假设一维数组dp[i]为Alice开始持有的数字i并获胜的概率</li>
<li>数组元素间的关系和初始值<ol>
<li>当 i&gt;N时，dp[i]=0;</li>
<li>当K&lt;=i&lt;=N时，dp[i]=1;</li>
<li>当0&lt;=i&lt;K时，dp[i]=(dp[i+1]+dp[i+2]+…+dp[i+W])/W;</li>
</ol>
</li>
<li>然后一步步倒退，可以计算出当dp[0]，即Alice开始持有的数字为0获胜的概率，即题解</li>
<li>为什么除以W<a href="https://leetcode-cn.com/problems/new-21-game/solution/zen-yang-de-dao-guan-fang-ti-jie-zhong-de-zhuang-t/" target="_blank" rel="noopener">参考链接</a></li>
</ol>
</li>
<li><p>时间复杂度空间复杂度O(N+M),但还可以再降</p>
</li>
</ol>
</li>
</ol>
<h3 id="2020-06-04"><a href="#2020-06-04" class="headerlink" title="2020/06/04"></a>2020/06/04</h3><ol>
<li><p>题目：<a href="https://leetcode-cn.com/problems/rotting-oranges/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotting-oranges/</a></p>
<p>该题为求无向图的最短路径，采用广度优先算法</p>
<ol>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//p1,p2为对应的x,y方向操作，目的是为了减少后面上下移动的代码重复度</span></span><br><span class="line">        <span class="keyword">int</span>[] p1 = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span>[] p2 = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">		Deque&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//计算新鲜橘子的数量</span></span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length ;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length ; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> ( grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">					queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i,j&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">					count++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; count &gt;<span class="number">0</span>) &#123; <span class="comment">//添加count&gt;0的原因是当第一次所有橘子都腐烂时，队列中还存在元素，但这一步并不需要计算在最短的时间内</span></span><br><span class="line">			time++;</span><br><span class="line">			<span class="keyword">int</span> size = queue.size();</span><br><span class="line">			<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size;i++) &#123; <span class="comment">//每一轮都将队列中的元素全部利用，即所有腐烂的橘子都会作用</span></span><br><span class="line">				<span class="keyword">int</span>[] temp = queue.poll();</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p1.length ;j++) &#123;</span><br><span class="line">					<span class="keyword">int</span> x = temp[<span class="number">0</span>] + p1[j];</span><br><span class="line">					<span class="keyword">int</span> y = temp[<span class="number">1</span>] + p2[j];</span><br><span class="line">					<span class="keyword">if</span>( x&gt;=<span class="number">0</span> &amp;&amp; x &lt; grid.length &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;grid[<span class="number">0</span>].length&amp;&amp;grid[x][y]==<span class="number">1</span>) &#123;</span><br><span class="line">						grid[x][y] = <span class="number">2</span>;</span><br><span class="line">						queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;x,y&#125;);</span><br><span class="line">						count--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (count!=<span class="number">0</span>) time = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>思路</p>
<ol>
<li>通过该题的描述，可以发现其本质是无向图的最短路径问题，故采用BFS。</li>
<li>初始时，首先进行遍历，将所有腐烂的橘子都加入到队列中，并统计新鲜橘子的数量；</li>
<li>在该题中，在每轮中，需要将腐烂的橘子的上下左右中存在的新鲜橘子加入的队列中，这里通过两个数组p1,p2来简化上下左右加入过程中的代码；</li>
<li>在问题的具体实现方面，需要注意的是，当第一次出现所有的橘子都被腐烂的情况时，队列中会加入新腐烂的橘子，队列不为空，所以使用<code>!queue.isEmpty() &amp;&amp; count &gt;0</code>来使得出现该情况时就会直接结束对队列的操作。</li>
</ol>
</li>
<li><p>时间复杂度？空间复杂度？</p>
</li>
</ol>
<ol start="2">
<li><p>题目：<a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/product-of-array-except-self/</a></p>
<ol>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">		<span class="keyword">int</span>[] Right = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">		<span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">		</span><br><span class="line">		output[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		Right[length-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; length; i++) &#123;</span><br><span class="line">			output[i] = output[i-<span class="number">1</span>] * nums[i-<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i = length - <span class="number">2</span>; i&gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">			Right[i] = Right[i+<span class="number">1</span>] * nums[i+<span class="number">1</span>];</span><br><span class="line">			output[i] *= Right[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<ol>
<li>在该题中，output[index]的值为下标index中的全部前缀元素与后缀元素的乘积，可以找到index与其前缀(后缀)元素积的关系，即<code>output[i] = output[i-1] * nums[i-1];</code>这里使用output先计算不同index的前缀元素积，后缀使用Right数组存放不同index对应的后缀元素积，有<code>Right[i] = Right[i+1] * nums[i+1];</code></li>
<li>当index=0时，前缀元素积存在初值1，当index=length-1时，后缀元素积有初值1</li>
</ol>
</li>
<li><p>时间复杂度O(n),空间复杂度O(n)</p>
</li>
</ol>
</li>
</ol>
<h3 id="2020-06-05"><a href="#2020-06-05" class="headerlink" title="2020/06/05"></a>2020/06/05</h3><ol>
<li><p>题目：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length ;</span><br><span class="line">		<span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> left = <span class="number">0</span> ,right = n-<span class="number">1</span> ,up = <span class="number">0</span> , down = m-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = left ;i &lt;= right;i++) &#123;</span><br><span class="line">				res[index++] = matrix[up][i];</span><br><span class="line">			&#125;</span><br><span class="line">			up++;</span><br><span class="line">			<span class="keyword">if</span>(up&gt;down) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span> ( <span class="keyword">int</span> i = up ; i &lt;= down ;i++) &#123;</span><br><span class="line">				res[index++] = matrix[i][right];</span><br><span class="line">			&#125;</span><br><span class="line">			right--;</span><br><span class="line">			<span class="keyword">if</span>(left&gt;right) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span> ( <span class="keyword">int</span> i = right ;i &gt;=left;i--) &#123;</span><br><span class="line">				res[index++] = matrix[down][i];</span><br><span class="line">			&#125;</span><br><span class="line">			down--;</span><br><span class="line">			<span class="keyword">if</span>(up&gt;down) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = down ; i &gt;= up;i--) &#123;</span><br><span class="line">				res[index++] = matrix[i][left];</span><br><span class="line">			&#125;</span><br><span class="line">			left++;</span><br><span class="line">			<span class="keyword">if</span>(left&gt;right) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路1</p>
<ol>
<li><p>主要实现的思路如下图所示，按照螺旋读取设置的读取顺序是右、下、左、上，而且在每一次读完一个方向时，矩阵的规模都会缩小，通过更改矩阵边界值up,down,left,right来实现</p>
<img src="https://pic.leetcode-cn.com/c6de3a1bc0f38820941dbcff0e17a49204eba91b967d4ccc0d5485e68a4fcc95-Picture1.png" alt="示意图" style="zoom:25%;">
</li>
<li><p>按照1中所描述的思路，我们可以使用while循环来实现螺旋读取，但是由于存在像上图一般的5的情况，当按照右读的顺序读取完就应该结束循环，由于不同矩阵的情况不同，在我们对某一个方向上的读取完成后都要进行一个判定，当某两条边界交错时（<code>up&gt;down</code>或者<code>left&gt;right</code>）就完成了读写，结束循环。</p>
</li>
<li><p>时间复杂度O(m*n)空间复杂度O(1)</p>
</li>
</ol>
</li>
<li><p>思路2：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/shun-shi-zhen-da-yin-ju-zhen-by-leetcode-solution/" target="_blank" rel="noopener">出处</a></p>
<ol>
<li><p>可以模拟打印矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，则顺时针旋转，进入下一个方向。</p>
<p>判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 <code>visited</code>，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 <code>visited</code>中的对应位置的元素设为已访问。</p>
<p>如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。</p>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][columns];</span><br><span class="line">        <span class="keyword">int</span> total = rows * columns;</span><br><span class="line">        <span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[total];</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, column = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            order[i] = matrix[row][column];</span><br><span class="line">            visited[row][column] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> nextRow = row + directions[directionIndex][<span class="number">0</span>], nextColumn = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nextRow &lt; <span class="number">0</span> || nextRow &gt;= rows || nextColumn &lt; <span class="number">0</span> || nextColumn &gt;= columns || visited[nextRow][nextColumn]) &#123; <span class="comment">//通过是否可能越界来判断是否需要转向</span></span><br><span class="line">                directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>; <span class="comment">//妙，方向轮转</span></span><br><span class="line">            &#125;</span><br><span class="line">            row += directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            column += directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度O(m*n),空间复杂度O(m*n)——因为多使用了<code>visit</code>数组</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>题目：<a href="https://leetcode-cn.com/problems/distribute-candies-to-people/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/distribute-candies-to-people/</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] distributeCandies(<span class="keyword">int</span> candies, <span class="keyword">int</span> num_people) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[num_people];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>,index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(candies&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            index++;</span><br><span class="line">            index = index % num_people;</span><br><span class="line">            <span class="keyword">if</span>(candies &gt;= count)&#123;</span><br><span class="line">                ans[index] += count;</span><br><span class="line">                candies -= count;</span><br><span class="line">                count++;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans[index] += candies;</span><br><span class="line">                candies=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：</p>
<p>使用count记录需要每次需要分发的糖果，使用<code>index = index % num_people</code>来实现分发对象的轮转。</p>
</li>
<li><p>时间复杂度O(max(sqrt(G),N))，空间复杂度O(1)</p>
</li>
</ol>
</li>
</ol>
<h3 id="2020-06-06"><a href="#2020-06-06" class="headerlink" title="2020/06/06"></a>2020/06/06</h3><ol>
<li><p>题目：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp , start = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> limit = (<span class="keyword">int</span>)Math.sqrt(<span class="number">2</span>*target);</span><br><span class="line">		List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = limit ;i &gt;= <span class="number">2</span>;i--) &#123;</span><br><span class="line">			temp = target - i*(i-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> ( temp % i == <span class="number">0</span>) &#123;</span><br><span class="line">				start = temp/i;</span><br><span class="line">				<span class="keyword">int</span>[] n = <span class="keyword">new</span> <span class="keyword">int</span>[i];</span><br><span class="line">				<span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; i;j++) &#123;</span><br><span class="line">					n[j] = start+j;</span><br><span class="line">				&#125;</span><br><span class="line">				list.add(n);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()][];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;res.length;i++) &#123;</span><br><span class="line">			res[i] = list.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路1：</p>
<ol>
<li><p>由题意值，target可以由下述数学公式表达<br>$$<br>target = na_1+\frac{n(n-1)}{2} ——（1）<br>$$<br>在该公式中，我们可以将n作为窗口的大小，a1作为该窗口的初始值<br>$$<br>a_1 = \frac{target-\frac{n(n-1)}{2}}{n} ——（2）<br>$$<br>在这个过程中，当a1=1时，我们可以计算出，最大的窗口应为2*target的平方(取整)。</p>
</li>
<li><p>在题目中要求序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。所以我们这里从“最大窗口数”开始进行遍历，找其中满足条件的n和a1的组合。</p>
</li>
<li><p>最后将List输出为二维数组。</p>
</li>
</ol>
</li>
<li><p>思路2——暴力滑窗法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//🧠里要有一个区间的概念，这里的区间是(1, 2, 3, ..., target - 1)</span></span><br><span class="line">        <span class="comment">//套滑动窗口模板，l是窗口左边界，r是窗口右边界，窗口中的值一定是连续值。</span></span><br><span class="line">        <span class="comment">//当窗口中数字和小于target时，r右移; 大于target时，l右移; 等于target时就获得了一个解</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>, sum = <span class="number">0</span>; r &lt; target; r++) &#123;</span><br><span class="line">            sum += r;</span><br><span class="line">            <span class="keyword">while</span> (sum &gt; target) &#123;</span><br><span class="line">                sum -= l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">                    temp[i] = l + i;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>题目：<a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-consecutive-sequence/</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span> ;</span><br><span class="line">        Set&lt;Integer&gt; numSet = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> x : nums)&#123;</span><br><span class="line">            numSet.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : numSet)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!numSet.contains(num-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> currentNum = num;</span><br><span class="line">                <span class="keyword">int</span> currentMax = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(numSet.contains(currentNum+<span class="number">1</span>))&#123;</span><br><span class="line">                    currentMax++;</span><br><span class="line">                    currentNum++;</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max,currentMax);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：</p>
<ol>
<li>遍历数组中的元素x，通过查看其相邻元素是否存在于数组之中来判断是否连续,连续序列应该是仅从这个序列最小的数开始查找判断的（这样可有效降低运行时间），这个通过判断x-1在数组中来实现仅从最小值开始，之后就判断x+1是否在数组中，并记录长度。</li>
<li>由于题目给定的数组中元素可能存在重复的情况，而且要求时间复杂度为O(n)，而且在这个过程中频繁应用“包含于”这样的语义，故将数组转换为HashSet，在HashSet中，使用contains(包含于)的时间复杂度为O(1),也可以满足题目要求。</li>
<li>时间复杂度O(n),空间复杂度O(n)</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2020-06-07"><a href="#2020-06-07" class="headerlink" title="2020/06/07"></a>2020/06/07</h3><ol>
<li><p>题目：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Deque&lt;Integer&gt; main_que;</span><br><span class="line">    <span class="keyword">public</span> Deque&lt;Integer&gt; sup_que;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        main_que = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        sup_que = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(main_que.isEmpty())   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> sup_que.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        main_que.offer(value);</span><br><span class="line">        <span class="keyword">while</span>(!sup_que.isEmpty()&amp;&amp;value &gt; sup_que.peekLast())&#123;</span><br><span class="line">            sup_que.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        sup_que.offer(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(main_que.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = main_que.poll();</span><br><span class="line">        <span class="keyword">if</span>(res == sup_que.peek())&#123;</span><br><span class="line">            sup_que.poll();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：</p>
<ol>
<li>push_back:向队列中传入元素；pop_front：删除队列头部元素</li>
<li>由于还要保存最大值，如果我们仅使用一个额外的int变量进行保存，那么当目前的最大值弹出，我们就无法及时知道弹出之后队列的最大值，所以这里需要使用一个辅助队列来存储当前队列的最大值以及可能出现的次大值，通过<code>!sup_que.isEmpty()&amp;&amp;value &gt; sup_que.peekLast()</code>使得在该辅助队列的队尾存储的值总是当前添加的值，这样不论主队列中的弹出顺序如何，辅助队列中总是存储着与之对应的最大值。</li>
<li>实现push_back的同时，要比较要压入的值如当前的最大值进行比较，实现最大值的更新；实现pop_front的时候，如果弹出的值是最大值，需要删除辅助队列中的相应值。</li>
</ol>
</li>
</ol>
</li>
<li><p>题目：<a href="https://leetcode-cn.com/problems/word-ladder-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder-ii/</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span> INF = <span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        Map&lt;String,Integer&gt; wordId = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//单词到ID</span></span><br><span class="line">        ArrayList&lt;String&gt; idWord= <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//id到单词</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将单词都加入至wordID中，每个单词有一个ID</span></span><br><span class="line">        <span class="keyword">for</span>(String s : wordList)&#123;</span><br><span class="line">            wordId.put(s,id++);</span><br><span class="line">            idWord.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//wordList中无enword</span></span><br><span class="line">        <span class="keyword">if</span>(!wordId.containsKey(endWord)) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//把begin加入</span></span><br><span class="line">        <span class="keyword">if</span>(!wordId.containsKey(beginWord))&#123;</span><br><span class="line">            wordId.put(beginWord,id);</span><br><span class="line">            idWord.add(beginWord);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//边</span></span><br><span class="line">        <span class="keyword">int</span> size = idWord.size();</span><br><span class="line">        ArrayList&lt;Integer&gt;[] edges = <span class="keyword">new</span> ArrayList[size]; <span class="comment">//edges存放的是对每个点的连接信息，所以其大小应为点的总数，存放的类型是List&lt;Integer&gt;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;size; i++ )&#123;</span><br><span class="line">            edges[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span> ; j &lt; size ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(differentNum(idWord.get(i),idWord.get(j)))&#123;</span><br><span class="line">                    edges[i].add(j);</span><br><span class="line">                    edges[j].add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dest = wordId.get(endWord);<span class="comment">//获取目标字符串对应的id</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] cost = <span class="keyword">new</span> <span class="keyword">int</span>[id+<span class="number">1</span>]; <span class="comment">//存放到每个点的代价,cost[i]为起点到i的距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt;id+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            cost[i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将起点加入队列</span></span><br><span class="line">        Queue&lt;ArrayList&lt;Integer&gt;&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; tmpBegin = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tmpBegin.add(wordId.get(beginWord));</span><br><span class="line">        que.add(tmpBegin);</span><br><span class="line">        cost[wordId.get(beginWord)] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//搜索</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * hit:0;hot:1;dot:2;dog:3;lot:4;log:5;cog:6.</span></span><br><span class="line"><span class="comment">        * 第一轮[0],第二轮[0,1],第三轮[[0,1,2],[0,1,4]],第四轮[[0,1,4],[0,1,2,3]]</span></span><br><span class="line"><span class="comment">        * 第五轮[[0,1,2,3],[0,1,4,5]],第六轮[[0,1,4,5],[0,1,2,3,6]],</span></span><br><span class="line"><span class="comment">        * 第七轮[[0,1,2,3,6],[0,1,4,5,6]]</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; current = que.poll();</span><br><span class="line">            <span class="keyword">int</span> last = current.get(current.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(last == dest)&#123;</span><br><span class="line">                ArrayList&lt;String&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> index : current)&#123;</span><br><span class="line">                    tmp.add(idWord.get(index));</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges[last].size() ;i++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> to = edges[last].get(i);</span><br><span class="line">                    <span class="keyword">if</span>(cost[last] + <span class="number">1</span> &lt;= cost[to])&#123;  <span class="comment">//这一条件是生成最短路径的关键,如在该情况下cost[4]=2,那么在[0,1,2]序列的时候就没有必要继续添加4了，因为此时起始点到4的距离更近</span></span><br><span class="line">                        cost[to]=cost[last]+<span class="number">1</span>;</span><br><span class="line">                        ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(current);<span class="comment">//将current的内容拷贝至tmp</span></span><br><span class="line">                        tmp.add(to);</span><br><span class="line">                        que.add(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">differentNum</span><span class="params">(String s1 , String s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i&lt; s1.length() &amp;&amp; res &lt; <span class="number">2</span> ;i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i)!=s2.charAt(i))&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：</p>
<ol>
<li>题中要求最短转换序列，则首先想到图的最短路径求法BFS，所以我们将该题所给数组抽象为图。将每个单词抽象为一个点，如果两个单词仅相差一个单词，我们则认为这两个点是连通的，边的权重都为1。</li>
<li>在具体转换为图的过程，为了操作简单，我们为每个单词建立一个序号，并建立单词、序号之间的双向映射(wordID和idWord),并建立这些单词之间的连通关系，即记录边的信息edges。</li>
<li>使用BFS对图进行遍历，并返回最后的解。</li>
<li><a href="https://leetcode-cn.com/problems/word-ladder-ii/solution/dan-ci-jie-long-ii-by-leetcode-solution/" target="_blank" rel="noopener">参考链接1</a></li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="六月-0608-0614"><a href="#六月-0608-0614" class="headerlink" title="六月 0608-0614"></a>六月 0608-0614</h2><h3 id="2020-06-08"><a href="#2020-06-08" class="headerlink" title="2020/06/08"></a>2020/06/08</h3><ol>
<li><p>题目：<a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/satisfiability-of-equality-equations/</a>  并查集</p>
<ol>
<li><p>代码——并查集Union-Find:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加权quick-union算法，通过sz数组将小树合并到大树上</span></span><br><span class="line"><span class="comment">//还可继续使用路径压缩的方法来优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span>[] id ;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span>[] sz;</span><br><span class="line">    <span class="keyword">int</span> count ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        sz = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">( <span class="keyword">int</span> p )</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (p!=id[p]) p = id[p];  <span class="comment">//未进行路径压缩的方法</span></span><br><span class="line">        <span class="keyword">return</span> p ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">connection</span><span class="params">(<span class="keyword">int</span> p , <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(find(p) == find(q)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p , <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pId = find(p);</span><br><span class="line">        <span class="keyword">int</span> qId = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pId == qId ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sz[pId] &lt; sz[qId])&#123;</span><br><span class="line">            id[pId] = qId;</span><br><span class="line">            sz[qId] += sz[pId];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            id[qId] = pId;</span><br><span class="line">            sz[pId] += sz[qId];</span><br><span class="line">        &#125;</span><br><span class="line">        count --; <span class="comment">//每合并一次，并查集的总数少一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码——具体实现部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(<span class="number">26</span>);<span class="comment">//equations中可能含有任意的小写字母</span></span><br><span class="line">        <span class="keyword">for</span>(String s : equations)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(<span class="number">1</span>) == <span class="string">'='</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> p = s.charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">char</span> q = s.charAt(<span class="number">3</span>);</span><br><span class="line">                uf.union(p-<span class="string">'a'</span>,q-<span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( String s : equations)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(<span class="number">1</span>) == <span class="string">'!'</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> p = s.charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">char</span> q = s.charAt(<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span>(uf.connection(p-<span class="string">'a'</span>,q-<span class="string">'a'</span>)) <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：</p>
<p>将 <code>equations</code> 中的算式根据 <code>==</code> 和 <code>!=</code> 分成两部分，先处理 <code>==</code> 算式，使得他们通过相等关系各自结合形成集合，<code>!=</code> 算式，不等号即两者不连通，若不等式两端的字母处在同一个集合，则有矛盾，返回false。</p>
</li>
</ol>
</li>
<li><p>题目：<a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change/</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount &lt; <span class="number">0</span> ) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp,amount+<span class="number">1</span>);<span class="comment">//dp[i]恒小于amount+1</span></span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;dp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x : coins)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i-x &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i] = Math.min(dp[i],<span class="number">1</span>+dp[i-x]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[amount] == amount+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：</p>
<ol>
<li><p>dp[i]为凑成总金额i过程中所需要的最少的硬币数，当amout = 0时，dp[0] = 0。<br>$$<br>dp[i] = min{dp[i-coin]|coin\ in\ coins}<br>$$<br>这样就可以使用动态规划的思想来进行问题的求解。</p>
</li>
<li><p>BFS:等价于在图上求最短路径，起点为amout，终点为0。使用visited数组记录某个节点是否被访问，防止重复访问，之后采用BFS求解即可。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2020-06-09"><a href="#2020-06-09" class="headerlink" title="2020/06/09"></a>2020/06/09</h3><ol>
<li><p>题目：<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; n = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(num&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">            n.add(num%<span class="number">10</span>);</span><br><span class="line">            num = num/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n.add(num);</span><br><span class="line">        <span class="keyword">int</span> sz = n.size();</span><br><span class="line">        <span class="keyword">if</span>(sz==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[sz];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(sz &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n.get(sz-<span class="number">1</span>)*<span class="number">10</span> + n.get(sz-<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= <span class="number">10</span> &amp;&amp; temp&lt;=<span class="number">25</span>) dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">3</span> , j = <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- ,j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = n.get(i+<span class="number">1</span>)*<span class="number">10</span> + n.get(i);</span><br><span class="line">                <span class="keyword">if</span>( tmp &gt;= <span class="number">10</span> &amp;&amp; tmp &lt;= <span class="number">25</span>) dp[j] = dp[j-<span class="number">1</span>]+ dp[j-<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[j] = dp[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sz-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：</p>
<ol>
<li><p>使用动态规划的思想，dp[i]为i位数最多的翻译方法，当第i位与i-1位组成的数字在[0,25]之间，dp[i] = dp[i-1]+dp[i-2];否则dp[i] = dp[i-1];<br>$$<br>temp=dp[i]+dp[i-1]*10;\<br>dp[i]=\begin{cases} dp[i-1]，0&lt;temp&lt;10\ dp[i-1]+dp[i-2]， 9&lt;temp&lt;26\end{cases}<br>$$</p>
</li>
<li><p>在具体实现方面，为了方便将num中的数字进行添加和组合，将num转换为数字列表，方便实现存取。</p>
</li>
<li><p>在初值方面，dp[0]= 1，dp[1]=1或2。</p>
</li>
<li><p>时间复杂度O(n),空间复杂度O(N)</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>题目：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(sz &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第i天的最大利润=第i天卖出价格-i天内买入的最低价格</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span> , min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            max = Math.max(max, prices[i] - min);</span><br><span class="line">            min = Math.min(min , prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：</p>
<p>使用dp思想，第i天获得的最大利润dp[i]=第i天的卖出价格price[i]-i天内最低的买入价格min，题目的解是最大的利润，所以我们直接可以使用max进行目前最大利润的存储，不需要记录所有的dp[i]。</p>
</li>
</ol>
</li>
</ol>
<h3 id="2020-06-10"><a href="#2020-06-10" class="headerlink" title="2020/06/10"></a>2020/06/10</h3><ol>
<li><p>题目：回文数<a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-number/</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   使用了字符串的解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        List&lt;Integer&gt; num = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(x&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">            num.add(x%<span class="number">10</span>);</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num.add(x);</span><br><span class="line">        <span class="keyword">int</span> sz = num.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ,j = sz-<span class="number">1</span>;i&lt;sz;i++,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num.get(i)!=num.get(j)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    不使用字符串的解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">isPalindrome1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, temp = x;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>)   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">            res = res*<span class="number">10</span> + temp%<span class="number">10</span>;</span><br><span class="line">            temp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res*<span class="number">10</span>+temp;</span><br><span class="line">        <span class="keyword">return</span> x==res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>思路：</p>
<ol>
<li>使用字符串，即将num中的各个数字分离开，通过比较前序读和后序读的数字是否一致来判断是否为回文。</li>
<li>不使用字符串，正常的num从左到右，位次由高到低，如果其是回文，则从右往左读，位次由高变低，得到的数字应与num相等。</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>题目：二叉树的直径<a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a> no</p>
<ol>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      TreeNode left;</span><br><span class="line">      TreeNode right;</span><br><span class="line">      TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//    public int rdeep = 0;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deepTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = deepTree(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = deepTree(root.right);</span><br><span class="line">        ans = Math.max(ans,left+right);</span><br><span class="line">        <span class="keyword">return</span>  Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        deepTree(root);</span><br><span class="line">        <span class="keyword">return</span> ans-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：</p>
<ol>
<li>一颗二叉树的直径长度是任意两个节点路径长度中的最大值，这条路径不一定经过根节点。</li>
<li>root的高度=max(左子树的高度，右子树的高度)+1；root的直径=左子树的高度+右子树的高度。但是直径路径不一定经过根节点，所以需要去搜索一遍root所有的子树对应的直径，去取最大值。</li>
</ol>
</li>
</ol>
</li>
<li><p>题目:<a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/</a> no</p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*该题还可以使用双指针遍历，</span></span><br><span class="line"><span class="comment">    * 使用双指针left，right, 从数组两头开始一起找，节约时间</span></span><br><span class="line"><span class="comment">    * 当 left + 1 &lt; right 的约束下，可以找到数组两头的和都是 sum/3,那么中间剩下的元素和就一定也是sum/3;left + 1 &lt; right的约束就是要中间有剩下的元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> av = <span class="number">0</span> ,sz = A.length,count = <span class="number">3</span> , sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : A)&#123;</span><br><span class="line">            av += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(av%<span class="number">3</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        av /= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;sz;i++) &#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            <span class="keyword">if</span>(sum==av)&#123;</span><br><span class="line">                <span class="keyword">if</span>(--count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//当count=0时，无论是否遍历至最后一个数字，都已经存在3个分组了，此时后面剩余的数字的均值都为0，可任意合并，故可直接退出</span></span><br><span class="line">                sum=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>思路</p>
<p>   计算出每个分块需要的和的大小，之后遍历，找到满足三个分块即可，此时数组中若还有剩余，剩余部分和为0，可合并至第三个分块，故可不管。</p>
</li>
</ol>
<h3 id="2020-06-11"><a href="#2020-06-11" class="headerlink" title="2020/06/11"></a>2020/06/11</h3><ol>
<li><p>题目:每日温度<a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/daily-temperatures/</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">       <span class="keyword">int</span> sz = T.length , count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[sz];</span><br><span class="line">        Stack&lt;Integer&gt; sk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;sz ; i++)&#123;</span><br><span class="line">           <span class="keyword">while</span> (!sk.empty()&amp;&amp; T[i] &gt; T[sk.peek()])&#123;</span><br><span class="line">               <span class="keyword">int</span> index = sk.pop();</span><br><span class="line">               ans[index] = i - index;</span><br><span class="line">           &#125;</span><br><span class="line">           sk.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：</p>
<ol>
<li><p>该题要找的时某个数字的下一较大值，使用递减栈。将列表中的元素值存入栈中，当下一刻要存的值after大于栈顶的值top时，如果存入after将会破坏递减特性，故将栈中小于after的元素全部弹出，这些元素的下一较大值即为after。</p>
</li>
<li><p>该题是求元素间的距离，为了方便，在入栈的时候，我们仅存入索引，通过索引进行进栈出栈的动作。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>题目：下一个更大元素<a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-greater-element-i/</a></p>
<ol>
<li><p>代码：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; sk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sz = nums1.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[sz];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; nums2.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!sk.empty() &amp;&amp; sk.peek() &lt; nums2[i]) &#123;</span><br><span class="line">                map.put(sk.pop(),nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            sk.add(nums2[i]); <span class="comment">//该题直接存放元素即可，没必要存储索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!sk.empty()) map.put(sk.pop(),-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;sz;i++)&#123;</span><br><span class="line">            ans[i] = map.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：</p>
<pre><code>该题与题目一解题思路一致，但该题求得是nums1中元素在nums2中得下一更大值， 对nums2进行题目一同一得操作，然后需要将栈顶元素与下一更大值建立映射，之后从映射关系选取nums1中得元素完成求解</code></pre></li>
</ol>
</li>
<li><p>题目：下一个更大元素(2)<a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-greater-element-ii/</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[sz];</span><br><span class="line">        Stack&lt;Integer&gt; sk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Arrays.fill(ans,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">2</span>*sz ;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!sk.empty() &amp;&amp; nums[sk.peek()] &lt; nums[i%sz])</span><br><span class="line">                ans[sk.pop()%sz] = nums[i%sz];</span><br><span class="line">            sk.push(i%sz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<p>   该题主要在于循环数组的处理，我们只需要考虑索引indx在[0,2*nums.length)的情况即可,对于数组下标的处理使用模除即可满足数组元素的循环。</p>
</li>
</ol>
</li>
<li><p>题目：接雨水<a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/trapping-rain-water/</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height  )</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一个0要处理</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sz = height.length;</span><br><span class="line">        Stack&lt;Integer&gt; sk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; sz;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!sk.empty() &amp;&amp; height[sk.peek()] &lt; height[i] )&#123;</span><br><span class="line">                <span class="keyword">int</span> h = height[sk.peek()];</span><br><span class="line">                sk.pop();</span><br><span class="line">                <span class="keyword">if</span>(sk.empty()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> distance = i - sk.peek() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> min = Math.min(height[sk.peek()],height[i]);</span><br><span class="line">                sum = sum + distance*(min - h);</span><br><span class="line">            &#125;</span><br><span class="line">            sk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：</p>
<ol>
<li>利用前面几题的下一最大值的思想，当栈顶元素小于当前元素，说明在这两个元素之间可能存在水槽</li>
<li>在计算水槽的大小时，存在[2,1,0,1,3]这种复杂的情况，我们可以按不同的高度(层)差*距离差，计算不同的水槽大小，比如[2,1,0,1]时，高度差为1，距离差为1。在计算h=[2,1,0,1,3]时(0已经弹出),h[3]时对应的高度差为0，距离差为1。在计算h[1]时，高度差为1，距离差为3，得到总的水槽大小为4</li>
<li>距离差=当前元素下标-弹出栈顶元素top的下标；<br>高度差=min(当前元素值，当前栈顶值)-top;取min是因为存在[3,1,0,1,2,5]这种类似的情景</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2020-06-12"><a href="#2020-06-12" class="headerlink" title="2020/06/12"></a>2020/06/12</h3><ol>
<li><p>题目：两数之和<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/</a></p>
<ol>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        Map&lt;Integer,Integer&gt; set = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> another = target - nums[i] ;</span><br><span class="line">            <span class="keyword">if</span> (set.containsKey(another)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;set.get(another),i&#125;;</span><br><span class="line">            set.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<pre><code>在解决该题中，需要保持数组中元素和索引的对应关系，两层循环可以做到，但是时间复杂度不理想，可以借助哈希表来降低时间复杂度。在每一轮添加nums[i]时，检查哈希表中是否存在target-nums[i]并找出相应的索引即可。因为本题假设每种输入只对应一个答案，所以对target=9,nums=[5,4,4]这种情况不需要特别考虑。</code></pre></li>
</ol>
</li>
<li><p>题目：三数之和<a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum/</a></p>
<ol>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> lg = nums.length;</span><br><span class="line">        <span class="keyword">if</span> ( lg &lt; <span class="number">3</span> ) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> index = <span class="number">0</span> ; index &lt; lg ; index++)&#123;</span><br><span class="line">            <span class="keyword">int</span> right = lg - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> target = <span class="number">0</span> - nums[index];</span><br><span class="line">            <span class="keyword">if</span> ( index &gt; <span class="number">0</span> &amp;&amp; nums[index] == nums[index-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> left = index + <span class="number">1</span> ; left &lt; lg ; left++)&#123;</span><br><span class="line">                <span class="keyword">if</span> ( left &gt; index+<span class="number">1</span> &amp;&amp; nums[left] == nums[left-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span> ( right &gt; left &amp;&amp; nums[right] + nums[left] &gt; target) right--;</span><br><span class="line">                <span class="keyword">if</span> (left == right) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[right] + nums[left] == target)&#123;</span><br><span class="line">                    List&lt;Integer&gt; temp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                    temp.add(nums[index]);</span><br><span class="line">                    temp.add(nums[left]);</span><br><span class="line">                    temp.add(nums[right]);</span><br><span class="line">                    res.add(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<ol>
<li>如果将一个数固定A，那么该问题和两数之和就有一些类似，即B+C= target-num[i],这里可以使用双指针来简化操作。</li>
<li>2.将数组排序，并使用双指针。对于去重问题，最大的难点是其可能存在多个相同的数字，使得A+B+C=target，如[1,0,-1,1],target=0，对于该问题，我们可以通过在遍历中加入控制条件来实现，对A(最外层遍历)和对于left指针来说，只从离下一不同元素最近的元素开始，仅从它们中的最后以为开始。由于数组是有序的，所以可以容易使得的List内元素也是有序的。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2020-06-13"><a href="#2020-06-13" class="headerlink" title="2020/06/13"></a>2020/06/13</h3><ol>
<li><p>题目：<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/climbing-stairs/</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> past = <span class="number">2</span> , ppast = <span class="number">1</span> ,res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            res = past+ppast;</span><br><span class="line">            ppast = past;</span><br><span class="line">            past = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：</p>
<p>使用DP思想，dp[i]为爬i阶台阶的方法，dp[1]=1,dp[2] =2,dp[i]=dp[i-1]+dp[i-2]。由于在这个过程中，我们每次仅仅使用的只有dp[]的部分内容，所以可以直接使用两个变量来保存，即ppast和past。</p>
</li>
</ol>
</li>
<li><p>题目：最长上升序列<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       Stack&lt;Integer&gt; sk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sz = nums.length ,  res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(sz == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; sz ; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!sk.isEmpty() &amp;&amp; nums[i] &lt;= sk.peek())&#123;</span><br><span class="line">                res = Math.max(sk.size(),res);</span><br><span class="line">                max = Math.max(sk.pop(),max);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (max &gt; Integer.MIN_VALUE &amp;&amp; nums[i] &gt; max) res++;</span><br><span class="line">            sk.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(res,sk.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<ol>
<li>题目要求上升序列，可以采用单调栈的思想；</li>
<li>但是题目存在[1,3,6,7,9,4,10,5,6]这种情况，仅仅使用单调栈，在遍历至4时，会将6,7,9全部弹栈，之后将10压栈时，计算的序列长度为1,3,4,10，正确的应为1,3,6,7,9,10。所以我们在这里使用一个max记录前一升序序列中的最大值，若当前的nums[i]&gt;max，则通过res+1和max(res,sk.size())的方式延申前一较长升序序列。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2020-06-14"><a href="#2020-06-14" class="headerlink" title="2020/06/14"></a>2020/06/14</h3><ol>
<li><p>题目：<a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/submissions/</a></p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBestValue</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> sz = arr.length , res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[sz-<span class="number">1</span>] &lt; target/sz) <span class="keyword">return</span> arr[sz-<span class="number">1</span>]; <span class="comment">//sum(arr)&lt;target,直接返回最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] prefix = <span class="keyword">new</span> <span class="keyword">int</span>[sz+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= sz ; i++)<span class="comment">//计算前缀，方便求解</span></span><br><span class="line">            prefix[i] = prefix[i-<span class="number">1</span>] + arr[i-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span> , right = arr[sz-<span class="number">1</span>] ; <span class="comment">//原本这里的lfet和right都是下标，但是本题要寻找的解并不一定在数组arr中，这里使用值更贴合题意。</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> index = Arrays.binarySearch(arr,mid);</span><br><span class="line">            <span class="keyword">if</span> ( index &lt; <span class="number">0</span>) index = -index - <span class="number">1</span> ;</span><br><span class="line">            <span class="comment">//binarySearch的返回值：1、如果找到关键字，则返回值为关键字在数组中的位置索引;2、如果没有找到关键字，返回值为负的插入点值，所谓插入点值就是第一个比关键字大的元素在数组中的位置索引，即 (-(insertion point) - 1) 。</span></span><br><span class="line">            <span class="keyword">int</span> sum = prefix[index] + (sz-index)*mid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( sum &lt;= target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                res = mid; <span class="comment">//保存了使得sum小于targe的最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//随着mid的增加,对应的abs(sum-target)应该大-&gt;小-&gt;大，所以题解只可能是res和res+1,故需要比较</span></span><br><span class="line">        <span class="keyword">int</span> samllerSum = <span class="number">0</span> ,biggerSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : arr)&#123;</span><br><span class="line">            samllerSum += Math.min(x,res);</span><br><span class="line">            biggerSum += Math.min(x,res+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( Math.abs(samllerSum-target) &gt; Math.abs(biggerSum-target))</span><br><span class="line">            <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴力查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">problem1300</span><span class="params">(<span class="keyword">int</span>[] arr , <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"><span class="comment">//        随着value的增加，数组和与target的差值应该是大-&gt;小-&gt;大</span></span><br><span class="line">        <span class="keyword">int</span> sz = arr.length;</span><br><span class="line">        <span class="keyword">int</span> mean = target/sz;</span><br><span class="line">        <span class="keyword">int</span> pre = Integer.MAX_VALUE; <span class="comment">//记录前一轮的差值</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) max = Math.max(i,max);</span><br><span class="line">        <span class="keyword">if</span> (max &lt; mean) <span class="keyword">return</span> max;  <span class="comment">//总数和小于target</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mean ; ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> v : arr) sum+=Math.min(i,v);</span><br><span class="line">            <span class="keyword">int</span> temp = Math.abs(sum-target);</span><br><span class="line">            <span class="keyword">if</span> ( temp &gt;= pre) <span class="keyword">return</span> i-<span class="number">1</span>; <span class="comment">//比较差值，看前一点是否是最小值。</span></span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路1-二分查找：</p>
<ol>
<li>将数组排序，通过二分查找的方式不断缩短搜索空间，这里题解可能不为数组arr中的值，每次查找的范围不应该仅是数组中的离散元素(即仅通过索引查找)，应该是一个完整的区间(包括数组中的元素)，所以在具体二分查找的时候的搜索空间应在具体元素值的基础上进行变动。</li>
<li>在一般情况下，随着value值得增大，数组和与target的差值会大-&gt;小-&gt;大，所以我们只要记住使得sum&lt;=target的最大value值即可，题解必在value和value+1(sum&gt;target)之间。</li>
</ol>
</li>
<li><p>思路2——暴力查找</p>
<ol>
<li>一般情况下查找的下界应该为target/arr.length(),value值逐渐增大，且随着value值增大，数组和与target的差值会大-&gt;小-&gt;大；</li>
<li>所以比较每一轮sum和target的差值cut，并记录差值较小时的value值，一旦当前轮次的cut大于等于上一轮的cut值，我们就可以认为上一轮可能时符合题解的value，添加等于是为了在多个符合题解的方案中取最小的value</li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/25/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" data-id="ckaxwb6zf0000zwl58ofm668j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-操作系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time datetime="2020-05-14T03:03:20.000Z" itemprop="datePublished">2020-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><ol>
<li><p>操作系统定义</p>
<p>操作系统是控制和管理计算机硬件和软件资源、合理地组织<br>和管理计算机的工作流程以方便用户使用的程序的集合</p>
</li>
<li><p>操作系统的特征</p>
<ul>
<li><p>并发</p>
<ul>
<li>并发性：指两个或者多个事件在 同一时间间隔内发生，是一种串行的、交替的发生。</li>
<li>并行性（parallel）：指两个或者多个事件在同一时刻发生（同时发生）。</li>
</ul>
</li>
<li><p>共享</p>
<p>系统中有限的资源不在为某个用户独占，而是可供多个用户共享。共享的方式：<em>互斥共享<em>，</em>非互斥共享</em>(宏观上的并行，微观上的并发)</p>
</li>
<li><p>不确定性</p>
<p>也称异步性，指多道程序的并发执行环境下的执行顺序、开始时间和执行时间是<strong>不确定的</strong></p>
</li>
<li><p>确定性</p>
<p>在相同的环境下，无论执行顺序等，结果总是相同的</p>
</li>
</ul>
</li>
<li><p>分时系统的特征</p>
<ul>
<li>同时性：一台主机链接多台主机</li>
<li>独立性</li>
<li>及时性</li>
<li>交互性</li>
</ul>
<p>实时系统对相应时间要求比较严格，专用系统</p>
</li>
<li><p>网络操作系统特征：</p>
<ul>
<li>分布性</li>
<li>自治性</li>
<li>互连性</li>
<li>可见性</li>
<li>NOS的3大部分：<strong>网络驱动程序；网络协议程序；应用程序接口软件</strong></li>
</ul>
</li>
</ol>
<h2 id="二、作业管理和用户接口"><a href="#二、作业管理和用户接口" class="headerlink" title="二、作业管理和用户接口"></a>二、作业管理和用户接口</h2><h2 id="2-1-作业的组织和管理"><a href="#2-1-作业的组织和管理" class="headerlink" title="2.1 作业的组织和管理"></a>2.1 作业的组织和管理</h2><h3 id="2-1-1-作业和作业处理过程"><a href="#2-1-1-作业和作业处理过程" class="headerlink" title="2.1.1 作业和作业处理过程"></a>2.1.1 作业和作业处理过程</h3><ol>
<li><p>作业：就是用户一次请求计算机系统为他完成任务所进行的工作总和。</p>
<p>作业会被细分为若干作业步</p>
</li>
<li><p>脱机作业：批处理系统</p>
<p>联机作业：分时系统</p>
<p>脱机作业控制方式：用户将数据、程序、故障处理一起输入系统</p>
<p>联机作业控制方式：人机对话控制作业运行</p>
</li>
<li><p>作业 = 程序 + 数据 + 作业控制信息（作业基本情况，作业控制描述，作业资源要求描述）</p>
</li>
<li><p>作业处理过程</p>
<ul>
<li><p>输入：提交数据</p>
</li>
<li><p>后备：建立作业控制块（PCB），加入后备作业队列，等待调度</p>
</li>
<li><p>执行：成功调度，分配资源，可进一步分为<strong>就绪、运行、阻塞</strong>状态</p>
</li>
<li><p>完成</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F" alt="image-20200513165650602"></p>
</li>
</ul>
</li>
</ol>
<h3 id="2-1-2-作业的输入-输出方式"><a href="#2-1-2-作业的输入-输出方式" class="headerlink" title="2.1.2 作业的输入/输出方式"></a>2.1.2 作业的输入/输出方式</h3><ol>
<li>SPOOLing系统：外围设备同时联机操作</li>
</ol>
<ul>
<li>SPOOLing系统的核心思想是利用一台可共享的、高速大容量的块设备（磁盘）来模拟独占设备的操作，使一台独占设备变成多台可并行使用的虚拟设备。</li>
<li>SPOOLing系统由专门负责I/O的常驻内存的进程和输入井、输出井组成</li>
</ul>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/SPOOLing" alt="image-20200513170326835"></p>
<p>​    Sp1和sp2是系统进程，优先级高于用户进程。SP1，SP2模拟脱机输入的时候的外围机，SP1将用户要求数据从输入设备通过缓冲区送到输入井。CPU直接从输入井将数据读入内存。</p>
<ol start="2">
<li><p><em>SPOOLing</em>系统的优点</p>
<ul>
<li><p>提高了I/O速度：将对低速I/O设备进行操作演变为对输入/输出井中数据的存取，缓和了CPU与低速I/O设备的速度不匹配矛盾</p>
</li>
<li><p>将独占设备改造为共享设备</p>
</li>
<li><p>实现了虚拟设备功能：宏观上，多个进程同时使用一台独立设备，而对每个进程而言，它们都认为自己是独占了一个设备</p>
</li>
</ul>
</li>
</ol>
<h3 id="2-1-3-作业控制块（JCB）"><a href="#2-1-3-作业控制块（JCB）" class="headerlink" title="2.1.3 作业控制块（JCB）"></a>2.1.3 作业控制块（JCB）</h3><ol>
<li>作业控制块（JCB）是作业存在的<strong>唯一标志</strong>，是系统为管理作业所设置的一个数据结构。包括该作业的标识信息、状态信息、调度参数、资源需求和其他控制信息。</li>
<li>作业后备队列就是按照某种原则将后备作业的JCB排成的一个或多个序列，以便作业调度。</li>
</ol>
<h3 id="2-1-4-作业调度"><a href="#2-1-4-作业调度" class="headerlink" title="2.1.4 作业调度**"></a>2.1.4 作业调度**</h3><ol>
<li><p>作业调度</p>
<p>在一些操作系统中，一个作业从提交到完成需要经过高级、中级和低级三级调度</p>
<ul>
<li>高级调度：即<strong>作业调度</strong>，选择后备作业，为其建立进程，并使其进入主机</li>
<li>中级调度：即<strong>对换调度</strong>，决定进程在内存和辅存盘交换区间的对换。</li>
<li>低级调度：即<strong>进程级调度</strong>，决定哪个进程可以占用CPU，进入运行状态。</li>
</ul>
</li>
</ol>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6" alt="image-20200513171258140"></p>
<ol start="2">
<li><p><strong>作业调度算法</strong></p>
<ol>
<li><p>评价因素</p>
<ul>
<li><p>CPU利用率</p>
</li>
<li><p>吞吐量：单位时间内CPU完成作业的数量</p>
</li>
<li><p>周转时间：通常与周转系数一起作为评价批处理系统的性能指标，定义如下</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4.png" alt="image-20200513171657214"></p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>我认为在这个过程中，提交时间和完成时间都是时刻，只有执行时间是时间间隔</p>
<p>当作业提交后立即执行，这样周转时间等于执行时间</p>
</blockquote>
<ol start="2">
<li><p>常见<strong>单道</strong>批处理系统的作业调度算法</p>
<ol>
<li>先来先服务（FCFS）<ul>
<li>按作业到达先后进行调度，即启动等待时间最长的作业</li>
<li>这种算法忽视了吞吐量和平均周转时间，有利于长作业，不利于短作业，有利于CPU繁忙的作业，不利于I/O繁忙的作业</li>
</ul>
</li>
<li>短作业优先调度算法（SJF）<ul>
<li>以要求运行时间长短进行调度，即启动要求运行时间最短的作业。</li>
<li>这种算法可以有效降低作业的平均等待时间，提高系统的吞吐量，但对长作业不利</li>
</ul>
</li>
<li>最高相应比优先调度算法(HRP)———<ul>
<li>优先调度相应比高的作业</li>
<li>响应比RP＝作业响应时间/作业估计运行时间  ＝（作业估计运行时间+作业等待时间）/作业估计运行时间  ＝ 1 + 作业等待时间/作业估计运行时间</li>
</ul>
</li>
</ol>
</li>
<li><p>常见多道批处理系统的作业调度算法</p>
<ol>
<li><p>优先级调度算法</p>
<p>由用户指定作业优先级，优先级高的作业先启动。指定原则：</p>
<p>①照顾时间要求紧迫的作业；</p>
<p>②照顾“I/O繁忙”的作业，以充分发挥外设的效率；</p>
<p>③在一个兼顾分时操作和批量处理的系统中，照顾终端会话型作业，以便获得合理的响应时间。</p>
</li>
<li><p><strong>均衡</strong>调度算法</p>
<p>这种算法的基本思想是根据系统的运行情况和作业本身的特性对作业进行<strong>分类</strong>。作业调度程序<em>轮流地从这些不同类别的作业中挑选作业执行</em>。这种算法力求均衡地使用系统的各种资源。即注意发挥系统效率，又使用户满意。比如把出现在输入井中的作业分成A、B、C三个队列： </p>
<ul>
<li>A队：短作业，其计算时间小于一定值，无特殊外设要求； </li>
<li>B队：要用到磁带的作业；</li>
<li>C队：长作业，其计算时间超过一定值。 </li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="2-2-系统功能调用"><a href="#2-2-系统功能调用" class="headerlink" title="2.2 系统功能调用"></a>2.2 系统功能调用</h2><ol>
<li><p>程序级接口－系统调用是<strong>操作系统</strong>提供给软件开发人员的接口</p>
</li>
<li><p>系统调用及实现</p>
<ol>
<li><p>程序的状态：计算机系统中的程序大体上分为<em>系统程序和用户程序</em>，前者是后者的管理者。为了便于管理，引入了</p>
<ul>
<li><p><strong>管态</strong>（系统态）：操作系统程序运行的状态</p>
</li>
<li><p><strong>算态</strong>（目态）：用户程序运行的状态</p>
</li>
</ul>
</li>
<li><p><strong>特权指令</strong>：<strong>特权指令</strong>是一类只能在管态下执行而不能在算态下执行的特殊的指令。这些指令在不同的机器中有不同的规定，通常与硬件有很大的关系，常见的特权指令有如下几类：</p>
<ul>
<li><p>传送程序状态字的指令</p>
</li>
<li><p>启动、测试和控制外设的指令</p>
</li>
<li><p>存取特殊寄存器的指令</p>
</li>
</ul>
</li>
<li><p>系统功能调用</p>
<ul>
<li><p><strong>访管指令</strong>：本身不是特权指令，基本功能是“<strong>自愿进管</strong>”，能引起访管中断。</p>
</li>
<li><p><strong>系统功能调用</strong>就是用户在程序中用访管指令调用由操作系统提供的子功能集合。有时把其中的每一个子功能称为一条广义指令。</p>
</li>
</ul>
</li>
</ol>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="系统调用过程"></p>
<ol start="4">
<li><p>系统调用与一般过程调用的区别</p>
<ul>
<li><p>运行在不同的系统状态：一般的过程调用，其调用和被调用的过程都运行在同一状态下，即管态或目态；而系统调用的调用过程是用户程序，运行在用户态，其被调用过程是系统过程，运行在系统态。</p>
</li>
<li><p>进入方式不同：一般的过程调用可直接由调用过程转向被调用过程；而执行系统调用时只能通过<strong>软中断机制，先进入操作系统核心</strong>，才能转向相应的处理程序。</p>
</li>
<li><p>返回问题：一般的过程调用，当被调用过程执行完后，将返回到调用过程继续执行。然而在采用抢先式调度的系统，在系统调用返回时，<em>要进行重新调度的检查―是否有更高优先级的任务就绪</em>。</p>
</li>
<li><p>嵌套或递归调用：对<strong>系统调用，一般不允许在同一个进程中发生嵌套或递归（</strong>不同进程可以重入同一个系统调用）</p>
</li>
</ul>
</li>
<li><p>系统调用的功能</p>
<p>设备管理：设备的读写与控制</p>
<p>文件管理：文件读写、文件控制和文件保护</p>
<p>进程控制：创建、终止、暂停等控制</p>
<p>进程通信：消息队列、共享存储区、socket等通信渠道的建立、使用和删除</p>
<p>存储管理：内存的申请和释放</p>
<p>系统管理：设置和读取时间、读取用户和主机标识等</p>
</li>
</ol>
</li>
</ol>
<h1 id="三、进程管理"><a href="#三、进程管理" class="headerlink" title="三、进程管理"></a>三、进程管理</h1><h2 id="3-1-进程的引入"><a href="#3-1-进程的引入" class="headerlink" title="3.1 进程的引入"></a>3.1 进程的引入</h2><ol>
<li><p>程序的顺序执行和并发执行</p>
<p>顺序执行——顺序性、封闭性（独占资源）、可再现性</p>
</li>
<li><p>多道程序设计：把一个以上的程序放入内存中，并且同时处于运行状态，这些程序共享CPU和其它资源；交替、穿插执行。其优点：</p>
<ul>
<li>CPU利用率高。</li>
<li>设备利用率高。</li>
<li>系统吞吐量大。</li>
</ul>
</li>
<li><p>并发执行的特征</p>
<ul>
<li>失去封闭性：共享资源，程序之间互相制约。</li>
<li>出现相互制约关系：虽然每个程序还是一个相对独立的实体，但由于程序的并发执行，使得一个程序的顺序执行要依赖于其他程序的执行结果，这样就形成了相互制约的关系。</li>
<li>间断性：程序之间的制约关系致使程序执行时间不连贯。</li>
<li>不可再现性：失去封闭性，也就失去了可再现性，程序执行的结果随速度、环境的不同而不同。</li>
<li>程序与计算的不一致（涉及临界资源的不同访问情况可能会出现不同的结果）</li>
</ul>
</li>
</ol>
<h2 id="3-2-进程定义和控制"><a href="#3-2-进程定义和控制" class="headerlink" title="3.2 进程定义和控制"></a>3.2 进程定义和控制</h2><h3 id="3-2-1-进程的定义"><a href="#3-2-1-进程的定义" class="headerlink" title="3.2.1 进程的定义"></a>3.2.1 进程的定义</h3><ol>
<li><p>进程概述</p>
<blockquote>
<p> 能够反映程序执行的独立性、并发性和动态性等特征  </p>
</blockquote>
<ul>
<li><p>进程是程序的一次执行</p>
</li>
<li><p>进程是可以和别的计算<strong>并发</strong>执行的计算</p>
</li>
<li><p>进程是定义在一个<strong>数据结构</strong>上并能在其上进行操作的一个程序（此处数据结构对应PCB？）</p>
</li>
<li><p>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的<strong>一个独立单位</strong>（线程是基本单位）</p>
</li>
</ul>
</li>
<li><p>进程和程序的区别</p>
<ul>
<li>程序是静态的，进程是动态的——程序是有序代码的集合,属于静态的文本概念；进程是程序的一次执行。</li>
<li>程序是长久的，进程是暂时的——进程是一个状态变化的<strong>过程</strong>，程序可长久保存</li>
<li>组成不同——进程的组成包括      <em>程序、数据和进程控制块</em>（即进程状态信息）</li>
<li>进程与程序的对应关系——通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。</li>
</ul>
</li>
<li><p>进程定义</p>
<p>​    是程序的一次执行，该程序可与其它程序并发执行；它是一个动态实体，在传统的操作系统设计中，<strong>进程既是基本的分配单位，也是基本的执行单位</strong>。</p>
</li>
<li><p>进程的组成</p>
<p>​    程序段 + 数据 + 进程控制块（PCB）</p>
<ul>
<li>程序和数据是进程存在的物理基础，是进程的实体</li>
<li>进程控制块是进程的灵魂，是进程存在的<strong>唯一标志</strong></li>
<li>操作系统为进程<strong>创建进程控制块和分配地址空间</strong>的过程就是进程创建的过程</li>
</ul>
</li>
<li><p>进程控制块</p>
<p>​    是操作系统用来记录<strong>进程详细状态和相关信息的基本数据结构</strong>，包括进程的<strong>标识</strong>信息、<strong>状态</strong>信息和<strong>控制</strong>信息。</p>
<ul>
<li><strong>标识信息</strong>：唯一的标识一个进程，主要有进程标识、用户标识和父进程标识。</li>
<li><strong>状态信息</strong>：与CPU有关的各种现场信息，包括寄存器状态、堆栈指针。以便该进程重新占用CPU后能够继续执行。——<strong>方便中断</strong></li>
<li><strong>控制信息</strong>：操作系统对进程进行调度管理时用到的信息。主要有进程状态、调度信息、队列指针、资源占有使用信息等。</li>
</ul>
</li>
</ol>
<p>​           PCB在内存中是以表的形式存在的－<strong>PCB表</strong>。还可以将相同性质的进程组织在一张表中，形成多个索引表。</p>
<ol start="6">
<li><p><strong>进程基本状态</strong></p>
<ul>
<li><p>运行态（Running）：进程已经获得所需资源，并占有CPU</p>
</li>
<li><p>就绪态（Ready）：已经获得所需资源，只等待CPU</p>
</li>
<li><p>阻塞态（Blocked）：也称为等待态、挂起态或睡眠态等，进程等待某个事件，如等待I/O完成，等待某个资源</p>
<p>此外，还可以有新建态、终止态。</p>
</li>
</ul>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2" alt="进程控制转换"></p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/PCB%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97" alt="PCB链表队列"></p>
</li>
</ol>
<h3 id="3-2-2-进程控制"><a href="#3-2-2-进程控制" class="headerlink" title="3.2.2 进程控制"></a>3.2.2 进程控制</h3><ol>
<li><p>源于实现进程控制</p>
<p>​    原语是指由机器指令构成的可完成特定功能的程序段。它是一个机器指令的集合，在执行时不能被中断。多采用屏蔽中断方法实现。进程控制原语有：</p>
<ul>
<li>进程创建原语（create primitive）</li>
<li>进程撤消原语（destroy primitive）</li>
<li>进程阻塞原语（block primitive）</li>
<li>进程唤醒原语（wakeup primitive）</li>
<li>进程挂起原语（suspend primitive）</li>
<li>进程激活原语（active primitive）</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>进程关系的树型结构</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB%E7%9A%84%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84" alt="进程关系的树型结构"></p>
<p>主要优点：</p>
<ul>
<li>资源分配严格：子进程仅能分配到父进程所拥有的资源，用完后归还。</li>
<li>进程控制灵活：可根据需要给进程以不同的控制权限。</li>
<li>进程结构清楚，关系明确。</li>
</ul>
</li>
<li><p>进程特征</p>
<ul>
<li>独立性</li>
<li>制约性——一个进程的执行可能依赖其他进程的执行结果。</li>
<li>结构性——每个进程有固定结构，包括程序、数据和PCB三部分。</li>
<li>动态性</li>
<li>并发性——进程的重要特征，同时也是操作系统的重要特征。</li>
<li>异步性——进程按各自独立的不可预知的速度向前推进，这导致了进程执行的不可再现性</li>
</ul>
</li>
</ol>
<h2 id="3-3-进程调度"><a href="#3-3-进程调度" class="headerlink" title="3.3 进程调度"></a>3.3 进程调度</h2><p>​    进程调度属于低级调度，就是从就绪队列中，按照一定的算法选择某个进程占用CPU。</p>
<ol>
<li><p>进程调度算法：</p>
<ul>
<li><p>先来先服务FCFS</p>
</li>
<li><p>基于优先数的进程调度算法：数值大的优先级高</p>
</li>
<li><p>时间片轮转进程调度算法：系统规定一定的时间长度作为进程运行的时间，如果进程在这段时间内执行不完，就得让出CPU——固定/可变时间片</p>
</li>
<li><p>多级队列轮转调度算法</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95" alt="多级队列轮转调度算法"></p>
</li>
</ul>
</li>
<li><p>进程调度方式</p>
<p>当一个进程正在CPU上运行时，若有一个更为紧迫或更为重要的进程需要进行处理，或者说，如果有更高优先数的进程进入就绪队列时，如何分配CPU。通常有两种方式：</p>
<ul>
<li>不可剥夺方式（不可抢占方式，non-preemptive）</li>
<li>可剥夺方式（可抢占方式，preemptive）</li>
</ul>
</li>
<li><p>进程间的联系</p>
<ol>
<li><p>进程间同步</p>
<p>​    相互协作的进程要共同完成一个任务，它们之间要相互配合，需要在一些动作间进行同步，即<strong>一个进程的某个动作与协作进程的某些动作之间在时序上有一定的关系</strong>。</p>
<p>​    <img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5" alt="进程间的同步"></p>
<p>​    在司机和售票员中间存在：司机停车，售票员开门买票；售票员关门，司机才可开车</p>
</li>
<li><p>进程间互斥——互斥使用资源</p>
<p>​    当两个或两个以上的进程竞争同时只能被一个进程使用的资源时，例如竞争使用打印机</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5" alt="进程互斥"></p>
<p>案例：生产者-消费问题———产品为互斥资源</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据定义（未处理互斥资源问题）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	. . .</span><br><span class="line">&#125; item;</span><br><span class="line">item <span class="built_in">buffer</span>[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者进程</span></span><br><span class="line">item nextProduced;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (counter == BUFFER_SIZE); </span><br><span class="line">		<span class="built_in">buffer</span>[in] = nextProduced;</span><br><span class="line">		in = (in + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">		counter++;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者进程</span></span><br><span class="line">item nextConsumed;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (counter == <span class="number">0</span>); <span class="comment">/* do nothing */</span></span><br><span class="line">		nextConsumed = <span class="built_in">buffer</span>[out];</span><br><span class="line">		out = (out + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">		counter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>进程互斥问题</p>
<ol>
<li><p>临界区（互斥区）</p>
<p>在进程中涉及到临界资源的程序段叫临界区</p>
</li>
<li><p>使用互斥区原则</p>
<ul>
<li>当有若干个进程要求进入临界区时，应使<strong>一个进程进入临界区</strong>，它们不应相互等待而使谁都不能进入，即进程不能无限地停留在等待临界资源的状态。</li>
<li>一次<strong>只允许一个</strong>进程进入临界区中，即各进程互斥访问临界资源。</li>
<li>各进程使用临界资源的<strong>时间是有限**</strong>的**，即任何一个进程都必须在有限的时间内释放所占资源。</li>
</ul>
</li>
<li><p>解决互斥的软件算法：</p>
<ul>
<li><p>Dekker算法</p>
<p>​    设置一个整型变量turn，指示允许进入临界区的进程标识。假设现有两个进程P1和P2，当turn的值为1时，P1被允许进入；当turn的值为2时，P2被允许进入。进程退出临界区时，要把turn的值改为对方的标识符，就等于允许对方的进入。</p>
<p>​    缺点：不考虑进程的需要，强制进入临界区。</p>
</li>
<li><p>Peterson算法</p>
<p>​    它除设置整型变量turn外，还为每一个进程设置一个标志，指示该进程是否要求进入临界区。假设还是两个进程，都在等待进入临界区。先检查对方的标志，如果不在临界区（想进入），则检查turn的值，以确定是否可以进入。</p>
<p> 软件方法的缺点：反复测试共享变量的值，浪费时间和资源，产生“忙等待”。</p>
</li>
<li><p>其他（非软件）——测试与设置指令</p>
<p>​    设置一个布尔变量称为“锁”。当一个进程进入临界区时，先测试该变量的值，以确定是否可以进入，退出时，修改该变量的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">TestAndSet</span> <span class="params">(<span class="keyword">boolean</span> *target)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">boolean</span> rv = *target;</span><br><span class="line">				*target = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">return</span> rv;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">boolean</span> lock = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//Process P_i</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">			<span class="keyword">while</span>(TestAndSet(&amp;lock));</span><br><span class="line">				critical section</span><br><span class="line">			lock = <span class="literal">false</span>;</span><br><span class="line">				remainder section</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><p>信号量</p>
<ol>
<li><p>相关概念</p>
<ul>
<li><p>信号量（Semaphore）是表示资源的实体，是一个与队列有关的<strong>整型变量</strong>，其值<strong>仅能由P、V操作改变</strong>。</p>
</li>
<li><p>信号量分为：公用信号量和私用信号量。</p>
</li>
<li><p><strong>公用</strong>信号量:用于实现<strong>进程间的互斥</strong>，<strong>初值通常设为1</strong>(因为仅能让一个进程进入互斥区)，它所联系的一组并发进程均可对它实施<strong>P、V</strong>操作；</p>
</li>
<li><p><strong>私用</strong>信号量用于<strong>实现进程间的同步</strong>，初始值通常设为0或n，允许拥有它的进程对其实施<strong>P操作</strong>。</p>
</li>
</ul>
</li>
<li><p>信号量数据结构定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> </span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	pointer_PCB <span class="built_in">queue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//信号量说明</span></span><br><span class="line">semaphore s;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>P.V操作</p>
<ol>
<li><p>具体内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">P(s)</span><br><span class="line">  &#123;</span><br><span class="line">     s.value = s.value - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (s.value &lt; <span class="number">0</span>)  &#123;</span><br><span class="line">       该进程状态置为等待状态;</span><br><span class="line">       将该进程的PCB插入相应的等待队列末尾s.<span class="built_in">queue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">V(s)&#123;</span><br><span class="line">  s.value = s.value + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (s.value &lt; = <span class="number">0</span>)  &#123;  <span class="comment">//还有进程需要进入临界区</span></span><br><span class="line">    唤醒相应等待队列s.<span class="built_in">queue</span>中等待的一个进程</span><br><span class="line">    改变其状态为就绪态</span><br><span class="line">    并将其插入就绪队列</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>P</strong>、<strong>V</strong>操作是原语操作（primitive）</p>
<p>原语：是（由若干条机器指令构成的）完成某种特定功能的一段程序，具有不可分割性。即原语的执行必须是连续的，<strong>不允许被中断</strong>。</p>
</li>
<li><p>信号量的含义：</p>
<ul>
<li><code>s.value &gt;= 0</code>时，其值表示还有可用的资源数；</li>
<li><code>s.value &lt; 0</code> 时，其绝对值表示有多少个进程因申请该信号量表示的资源，得不到而进入阻塞态；</li>
</ul>
</li>
</ol>
</li>
<li><p>使用P.V操作解决进程间同步、互斥</p>
<ol>
<li><p>进程间同步——司机-售票员</p>
<p>用P，V操作实现司机－售票员同步：设置信号量S车，S门，初值均为0</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8F%B8%E6%9C%BA-%E5%94%AE%E7%A5%A8%E5%91%98" alt="司机-售票员"></p>
</li>
<li><p>进程间互斥——读者-写者问题</p>
<ol>
<li><p>问题描述：</p>
<p>​    多个读进程可以同时共享资源，但不能和写进程共享；写进程之间互斥，访问时必须独占资源。需设置一个全局变量对读进程进行计数，当第一个读进程开始进行访问时执行P操作，当最后一个读进程结束访问时执行V操作</p>
</li>
<li><p>参数设定</p>
<p>​    现假设<strong>读者优先</strong>。使用readnum对读者计数，初值为0；mutex是对readnum进行互斥操作的信号量，初值为1；write是写信号量，初值为1。</p>
</li>
<li><p>相关代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多个读者进程可共享资源，即他可以随时进入读</span></span><br><span class="line"><span class="comment">//读者进程</span></span><br><span class="line"><span class="built_in">begin</span></span><br><span class="line">	P(mutex);  <span class="comment">//这里的mutex我是为了保护readnum这个变量的</span></span><br><span class="line">	readnum=readnum+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (readnum==<span class="number">1</span>) P(<span class="built_in">write</span>);  <span class="comment">//第一个读者来执行P操作</span></span><br><span class="line">	V(mutex);</span><br><span class="line">	<span class="built_in">read</span> file;</span><br><span class="line">	P(mutex);</span><br><span class="line">	readnum=readnum－<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (readnum==<span class="number">0</span>) V(<span class="built_in">write</span>);  <span class="comment">//最后一个读者来执行V操作</span></span><br><span class="line">	V(mutex);</span><br><span class="line"><span class="built_in">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写者进程</span></span><br><span class="line"><span class="built_in">begin</span></span><br><span class="line">	P(<span class="built_in">write</span>);</span><br><span class="line">	<span class="built_in">write</span> file;</span><br><span class="line">	V(<span class="built_in">write</span>);</span><br><span class="line"><span class="built_in">end</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>复合问题——理发师问题</p>
<ol>
<li><p>问题描述：</p>
<p>​    理发店里有一个理发师、一把理发椅、n把供等候理发的顾客坐的椅子。如果没有顾客，则理发师便在理发椅上睡觉。当一个顾客到来时，他必须先叫醒理发师，进行理发。如果理发师在理发时又有顾客到来，则如果有空椅子可坐，他就坐下来等，如果没有空椅子，他就离开。为理发师和顾客各编写一段程序描述他们的行为，要求不能带有竞争条件。</p>
</li>
<li><p>信号量设置说明</p>
<p>​    设三个信号量：customers，<em>用来记录等待理发师的顾客数</em>（不包括正在理发的顾客），初值为0；<em>barbers，记录正在等候顾客的理发师数</em>，初值为0；mutex，用于互斥，初值为1。还需一个变量waiting，初值为0，也用于记录等候的顾客数，<em>实际上是customers的一个副本</em>。之所以使用waiting是因为无法读取信号量的当前值。在该解法中，进入理发店的顾客必须先看等待的 顾客数，如果少于椅子数，他留下来等，否则他就离开。</p>
</li>
<li><p>实际代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//理发师进程</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    P(customers);<span class="comment">//如果顾客为0，睡觉</span></span><br><span class="line">	    P(mutex);<span class="comment">//要求进程等候</span></span><br><span class="line">	    waiting=waiting<span class="number">-1</span>;<span class="comment">//等候顾客数减1</span></span><br><span class="line">	    V(barbers);<span class="comment">//一个理发师开始理发</span></span><br><span class="line">	    V(mutex);<span class="comment">//释放等候</span></span><br><span class="line">	     cuthair();<span class="comment">//理发</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顾客进程</span></span><br><span class="line">&#123;</span><br><span class="line">	P(mutex);<span class="comment">//进入临界区</span></span><br><span class="line">	<span class="keyword">if</span>(waiting&lt;CHAIRS)</span><br><span class="line"> 	&#123;</span><br><span class="line">	   waiting=waiting+<span class="number">1</span>;<span class="comment">//等候顾客数加1</span></span><br><span class="line">	    V(customers);<span class="comment">//如果必要，唤醒理发师</span></span><br><span class="line">	     V(mutex);<span class="comment">//释放访问等候</span></span><br><span class="line">	     P(barbers);<span class="comment">//如果barbers为0，就睡觉</span></span><br><span class="line">	     get_haircut();<span class="comment">//坐下等候服务</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;<span class="comment">//没空椅子，就离开</span></span><br><span class="line">		V(mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="4">
<li><p>对P，V操作的使用应注意：</p>
<ul>
<li>P，V操作都是成对出现的：<strong><em>互斥操作时，它们在同一进程中；同步操作时，它们处于不同的进程。</em></strong></li>
<li>在进程中，P操作的位置和次序至关重要。一般情况下，<strong><em>对互斥信号量的P操作在后</em></strong>。而V操作没有特别的限制。</li>
<li>P，V操作的优点是：原语完备，表达能力强，可以解决任何同步和互斥问题。</li>
</ul>
</li>
</ol>
<h2 id="3-5-进程通信"><a href="#3-5-进程通信" class="headerlink" title="3.5 进程通信"></a>3.5 进程通信</h2><ol>
<li><p>低级通信与高级通信</p>
<ul>
<li>低级通信和高级通信：根据交换信息量的多少和效率的高低，如P、V操作属于低级通信；高级通信包括管道通信和信箱通信。</li>
<li>低级通信只传递状态和整数值，信息量小，效率低，传递较多信息需要多次通信，编程复杂，不易理解。</li>
<li>高级通信能够传递大批量数据，减轻程序编制的复杂度。包括<em>共享内存模式<em>、</em>消息传递模式<em>和</em>共享文件模式（管道）</em></li>
</ul>
</li>
<li><p>共享内存</p>
<p>​        系统在内存中指定一个区域作为<strong>共享存储区</strong>，建立一张段表进行管理，各进程可以申请其中一个存储段，并在申请时提供关键字。若申请的存储区已经被其它进程占有，系统会向申请进程返回关键字，该存储区就链接到了进程的逻辑地址空间，此后进程就可以直接存取共享存储区中的数据了。</p>
</li>
<li><p>消息传递方式</p>
<p>​        把<strong>消息缓冲区</strong>作为进程通信的一个<strong>基本单位</strong>，借助系统的发送原语Send(A)和接收原语Receive(B)，实现进程间的通信。每当发送进程要发送消息时，发送进程用Send(A)原语把消息从发送区复制到消息缓冲区，并把它挂在接收进程的消息队列末尾。如果该进程因等待消息而处于阻塞状态，则将其唤醒。每当接收进程要读取消息时，用接收原语Receive(B)从消息队列头取走一个消息放到自己的接收区。</p>
<p>​        <strong>消息队列要看作临界资源</strong>，需要互斥访问，在PCB中设置了一个用于互斥的信号量。</p>
<p>​        类似于生产者-消费者问题。</p>
<ul>
<li><p>直接通信方式：</p>
<p> Send(P,message)：发送消息message到进程P</p>
<p> Receive(P,message)：从进程P接收消息message</p>
</li>
<li><p>间接通信方式：利用信箱作为媒介进行消息传递。</p>
</li>
</ul>
</li>
<li><p>管道（pipe）</p>
<p>​        是一种共享文件模式，基于<strong>文件系统</strong>，连接于两个进程之间，以<strong>先进先出</strong>的方式实现消息的<strong>单向传送</strong>。</p>
<p>​        在UNIX系统中，管道的创建用函数pipe()实现。读管道时调用read()函数，从管道中读取字节。写管道时调用write()函数，向管道写信息。</p>
<ul>
<li>通过<strong>系统调用</strong>write()和read()进行管道的读写。</li>
<li>进程间要进行双向通信，通常需要定义两个管道。</li>
<li>只适用于<strong>父子进程之间</strong>的通信。管道能够把信息从一个进程的地址空间拷贝到另一个进程的地址空间。</li>
</ul>
</li>
</ol>
<h2 id="3-6-线程"><a href="#3-6-线程" class="headerlink" title="3.6 线程"></a>3.6 线程</h2><ol>
<li><p>进程作为调度基本单位的问题</p>
<ul>
<li><p>进程的并发执行使得进程调度工作量增大，耗费系统资源进行进程调度和内存分配。</p>
</li>
<li><p>进程间通信延迟大，频率高的通信过程效率低下。</p>
</li>
<li><p>没有达到理想的并行度。</p>
</li>
</ul>
</li>
<li><p>定义</p>
<p>​    也叫轻型进程，是可执行的实体单元，可代替以往的进程，是处理机调度的<strong>基本单位</strong>。</p>
<p>​    在多线程环境中，进程被定义为保护单位和资源分配单位，在一个进程内部可以有多个线程。</p>
</li>
<li><p>特征</p>
<ul>
<li>执行状态包括创建、就绪、运行、阻塞等</li>
<li>当不处于执行状态时，要保存线程上下文环境</li>
<li><em>进程中的所有线程共享所属进程内的主存和其它资源。</em></li>
</ul>
</li>
<li><p>线程的优势</p>
<ul>
<li>创建和撤销线程的开销小：时间和空间</li>
<li>切换迅速：切换内容少</li>
<li>通信效率高：共享相同的地址空间</li>
<li>并发度高：线程个数没有限制</li>
</ul>
</li>
<li><p>实现机制</p>
<ol>
<li><p>用户级线程</p>
<ol>
<li>描述</li>
</ol>
<ul>
<li>由应用程序完成所有线程的管理</li>
<li>核心不知道线程的存在</li>
<li>线程切换不需要核心态特权</li>
<li>线程执行系统调度时整个进程被阻塞（这时候切换到管态，目态被阻塞）</li>
</ul>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B" alt="用户级线程"></p>
<ol start="2">
<li>优缺点<ul>
<li>优点：线程切换不调用核心； 调度是应用程序特定的：可以选择最好的算法</li>
<li>缺点：大多数系统调用是阻塞的，因此核心阻塞进程，故进程中所有线程将被阻塞</li>
<li>核心只将处理器分配给进程，同一进程中的两个线程不能同时运行于两个处理器上</li>
</ul>
</li>
</ol>
</li>
<li><p>核心级线程（KLT）</p>
<ol>
<li><p>描述</p>
<ul>
<li>所有线程管理由核心完成</li>
<li>没有线程库，但对核心线程工具提供API</li>
<li>核心维护进程和线程的上下文</li>
<li>线程之间的切换需要核心支持</li>
<li>以<strong>线程为基础</strong>进行调度</li>
</ul>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%A0%B8%E5%BF%83%E7%BA%A7%E7%BA%BF%E7%A8%8B" alt="核心级线程"></p>
</li>
<li><p>优缺点</p>
<ul>
<li><p>优点：</p>
<p>​    对多处理器，核心可以同时调度同一进程的多个线程；阻塞是在线程一级完成；核心例程是多线程的</p>
</li>
<li><p>缺点：</p>
<p>​       同一进程内的线程切换调用内核，导致速度下降</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="四、死锁"><a href="#四、死锁" class="headerlink" title="四、死锁"></a>四、死锁</h1><h2 id="4-1-死锁的基本概念"><a href="#4-1-死锁的基本概念" class="headerlink" title="4.1 死锁的基本概念"></a>4.1 死锁的基本概念</h2><ol>
<li>现象描述——两个或多个进程都占有其它进程请求的资源，每个进程都不能执行，处于永远的等待状态。</li>
</ol>
<p>​    2. 死锁主要是由两个或多个进程对资源需求的冲突引起的</p>
<p>​    <img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" alt="死锁的基本概念"></p>
<ol start="3">
<li>产生的原因——对互斥资源的共享，<strong>并发执行的顺序不当</strong><ul>
<li>任一时刻只能允许一个进程占有的资源叫做独占资源。</li>
<li>独占资源分为可剥夺式资源和不可剥夺式资源。</li>
<li>死锁与<strong>不可剥夺资源</strong>有关。</li>
</ul>
</li>
<li>产生死锁的四个必要条件<ul>
<li>互斥使用（资源独占）</li>
<li>非剥夺控制（不可强占）</li>
<li>零散请求：进程可以按需逐次申请资源，而不是集中性一次申请。</li>
<li>循环等待：等待进程形成一个封闭的链，链上的进程都在等待下一个进程占有的资源，造成了无止境的等待状态。</li>
</ul>
</li>
</ol>
<h2 id="4-2-死锁举例"><a href="#4-2-死锁举例" class="headerlink" title="4.2 死锁举例"></a>4.2 死锁举例</h2><ol>
<li><p>进程申请顺序不当引起死锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P.V操作不当，S1，S2初值都为0</span></span><br><span class="line"><span class="comment">//生产者进程P</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">生产一件产品;</span><br><span class="line">P(S1);<span class="comment">/*申请一个空缓冲区*/</span></span><br><span class="line">放入一件产品；</span><br><span class="line">V(S2); <span class="comment">/*释放缓冲区*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者进程Q</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">P(S2); <span class="comment">/*申请一个满缓冲区*/</span></span><br><span class="line">拿出一件产品;</span><br><span class="line">V(S1);</span><br><span class="line">消费产品;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同类资源分配不当引起死锁</p>
<p>​    假设系统中有9个单位的存储器，4个进程，每个进程都需要4个存储器才能完成。</p>
<p>​    现系统给每个进程都分配了2个存储器，系统还剩余1个存储器，但无论将其分配给哪一个进程，该进程都不能执行完成，造成了死锁。</p>
</li>
<li><p>进程通信引起死锁</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%BC%95%E8%B5%B7%E6%AD%BB%E9%94%81" alt="进程通信引起死锁"></p>
</li>
<li><p>由此可见，死锁的产生与系统拥有的资源数量、资源分配的策略、进程对资源申请和使用的时机等多个因素有关，要解决死锁需全面考虑这些因素。</p>
</li>
</ol>
<h2 id="4-3-解决死锁的方案"><a href="#4-3-解决死锁的方案" class="headerlink" title="4.3 解决死锁的方案"></a>4.3 解决死锁的方案</h2><ol>
<li><p>不让死锁发生</p>
<p>​    可以在进程执行前或在进程执行过程中，对资源的分配加以限制。</p>
<ul>
<li>静态策略：进程创建时就分配了其所需所有资源，满足后方可执行，执行过程中没有资源分配工作。</li>
<li>动态策略：在进程执行过程中改变资源的分配情况。</li>
</ul>
</li>
<li><p>预防死锁：可以从破坏死锁的必要条件入手</p>
<ol>
<li>破坏零散请求条件：可以采用静态分配策略，进程一次性申请并获得所需所有资源后才能执行。</li>
<li>破坏循环等待条件（<strong>单向申请资源</strong>）：按序分配资源。系统依据一定的策略给资源由低到高编号，进程必须按从小到大顺序申请资源，并规定进程占有的资源号小于申请的资源号才能得到申请资源。如，占有3号资源可以申请并可能获得5号资源，而占有5号资源申请3号资源，则得不到满足；若要得到3号资源，就必须放弃5号资源及其占有的所有比3大的资源。另外，资源很多时，可以采用多级序列。</li>
<li>用动态方法判断资源的使用情况和系统状态，在分配资源之前，系统将判断如果满足进程的请求是否会发生死锁。如果会，就不分配资源，从而避免死锁。系统状态分为安全状态和不安全状态：<ul>
<li>安全状态：指当多个进程动态申请资源时，系统将按照<strong>某种顺序逐次</strong>的为每个进程分配所需资源，使每个进程都可以在最终得到最大需求量后，依次顺利完成。即<strong>存在一个状态序列</strong>能够使所有的进程均得到它们所需的资源并执行结束。</li>
<li>不安全状态：如果<strong>不存在一个状态序列</strong>能够使所有的进程均执行结束，即为不安全状态。</li>
</ul>
</li>
</ol>
</li>
<li><p>银行家算法</p>
<pre><code>​    在资源分配时进行判断，分析系统状态是否安全</code></pre><ol>
<li><p>基本思想</p>
<pre><code>​    将系统资源比作贷款，申请资源的进程比作借款人，操作系统比作银行家。银行家不可能满足所有借款人所要求借款的总额，所以当某借款人提出借款时，银行家必须判断如果将款借出，会不会导致资金周转不灵。若会，则不借；否则，就借。</code></pre></li>
<li><p>算法过程</p>
<p> ​    对每一个资源申请进行检查，看如果满足该申请是否会导致不安全状态。若是，则不满足该申请，否则就满足。<strong>检查状态是否安全的方法是看是否有足够的资源满足一个距最大需求<em>最近</em>的进程。</strong>如果可以，则认为这些资源是可以收回的，然后检查下一个距最大需求最近的进程，如此反复下去。如果所有资源最终都被收回，则该状态是安全的，最初的申请可以满足。</p>
</li>
<li><p>多项资源的银行家算法：</p>
<p>​    设置资源的已分配矩阵R、尚需资源矩阵Q以及可分配资源向量available。(即找出一个序列使得系统可收回所有资源)</p>
<ul>
<li><p>如果某一进程对某一种资源提出申请，就假定预先分配给它，然后修改已分配矩阵R、尚需资源矩阵Q和向量available；</p>
</li>
<li><p><strong>在矩阵Q中找出一行，使该行向量小于等于available</strong>。若不存在这样的向量，就说明没有进程能够获得全部资源运行到完成，将会引起死锁；</p>
</li>
<li><p>假设被选中的那一行的进程获得资源并运行结束，把它占有的资源全部加入向量available；</p>
</li>
<li><p>重复(2)(3)步骤，直到下述情况之一出现：或者所有进程都完成，则系统是安全的，可以分配；或者发生死锁，则预先分配是不安全的，应不予分配。</p>
<p>​    假设系统中有4类资源：打印机5个、手写板7个、扫描仪8个和读卡器9个，分别表示为R1，R2，R3，R4；共有5个进程a，b，c，d，e，某时刻系统状态如下所示：</p>
</li>
</ul>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%93%B6%E8%A1%8C%E5%AE%B61" alt="银行家1"></p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%93%B6%E8%A1%8C%E5%AE%B62" alt="银行家2"></p>
</li>
<li><p>死锁的检测——让死锁发生</p>
<ol>
<li><p>资源分配图</p>
<pre><code>​    描述进程申请资源和资源分配情况的关系模型图，可以直观的检测系统是否会发生死锁。在资源分配图中，规定如下：</code></pre><ul>
<li>圆表示一个进程；</li>
</ul>
</li>
</ol>
<ul>
<li><p>方块表示一个资源类，其中的圆点表示该类资源中的单个资源；</p>
<ul>
<li><p>从资源指向进程的箭头表示资源被分配给该进程；</p>
</li>
<li><p>从进程指向资源的箭头表示进程申请一个这类资源。</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE1" alt="资源分配图1"></p>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>合理的资源分配图</p>
<p>​    设资源类Rj有资源Wj个，用|(Rj,Pi)|表示Rj分配给进程Pi的资源个数，用|(Pi,Rj)|表示进程Pi申请Rj的资源个数，则应满足两个条件：</p>
<ol>
<li><p>资源Rj分配给各进程的资源数目不能大于Wj，即</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E5%85%AC%E5%BC%8F1" alt="死锁公式1"></p>
</li>
<li><p>任何一个进程Pi对某类资源Rj的申请量和已分配数量之和，不能大于Wj，即</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E5%85%AC%E5%BC%8F2" alt="死锁公式2"></p>
</li>
</ol>
</li>
<li><p>化简资源分配图——判断是否发生死锁</p>
<ol>
<li><p>检查图中有无环路，如果没有，系统不会死锁，检测结束；如果有环路，进行下一步。</p>
</li>
<li><p>若<strong>环路中</strong>涉及的每个资源类中只有一个资源，系统一定死锁；若每个资源类中有多个资源，进行下一步。</p>
</li>
<li><p>在环路中查找非阻塞且非独立的进程Pi，应满足对任一资源类Rj</p>
<p> <img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E5%85%AC%E5%BC%8F3" alt="死锁公式3"></p>
<p> ​    即它可以在有限的时间里获得所需资源并执行完毕，从而释放占有资源。找到后，把与该进程相连的所有有向边去掉，形成孤立结点。如此反复，直到没有进程可被化简。</p>
</li>
<li><p>如果资源分配图中每个进程都化简成孤立结点，则系统不会死锁；否则，则会死锁。</p>
<p> 上面的资源分配图不会死锁。</p>
</li>
</ol>
</li>
<li><p>临时资源的死锁检查</p>
<ol>
<li><p>对资源分配图进行重新定义：</p>
<ul>
<li>圆表示一个进程；</li>
<li>方块表示一个资源类，其中的圆点表示该类资源中的单个资源；</li>
<li>从资源类指向进程的箭头表示该进程产生这种资源，一个箭头可表示产生一到多个资源，每个资源类至少有一个生产者进程；</li>
<li>从进程指向资源的箭头表示进程申请这类资源，一个箭头表示只申请一个资源。</li>
</ul>
</li>
<li><p>判断系统死锁是否死锁的关键在于判断<strong>生产者进程的状态</strong>，只要生产者进程不被阻塞，它总会产生出该类资源，申请这类资源的进程就都可以得到满足。</p>
<p> <img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%B4%E6%97%B6%E8%B5%84%E6%BA%90%E7%9A%84%E6%AD%BB%E9%94%81%E5%88%A4%E6%96%AD" alt="临时资源的死锁判断"></p>
</li>
</ol>
</li>
<li><p>死锁的解除</p>
<ol>
<li>重新启动：方法粗暴，实现简单，损失较大</li>
<li>撤销进程：逐个撤销或一次性撤销所有进程</li>
<li>剥夺资源：剥夺死锁进程的资源</li>
<li>进程回退：需要保留历史信息，比较成熟，广泛应用于DBMS中</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="五、文件管理"><a href="#五、文件管理" class="headerlink" title="五、文件管理"></a>五、文件管理</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li><p>一些叙述：</p>
<ul>
<li><p>冯·诺依曼原理：</p>
<p> 存储程序，执行程序。</p>
</li>
<li><p>并行系统</p>
<p>对系统中存在的多个程序进行管理，主要工作之一就是存储管理。</p>
</li>
<li><p>存储器的功能是保存指令和数据</p>
</li>
<li><p>存储体系</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BC%93%E5%AD%98%E4%BD%93%E7%B3%BB" alt="缓存体系"></p>
</li>
</ul>
</li>
<li><p>存储管理的目的</p>
<ul>
<li>通过地址转换，使得用户和用户程序不涉及内存物理的细节（对用户透明）</li>
<li>为用户程序完成程序的装入</li>
<li>提高内存的利用率，弥补用户对内存容量的需求和内存实际容量之间的差距</li>
<li>解决内存速度和CPU速度不匹配的问题</li>
<li>在不连续技术下，实现内存共享</li>
</ul>
</li>
<li><p>存储管理的任务</p>
<ul>
<li><p>存储分配和回收：是存储管理的主要内容。讨论其算法和相应的数据结构。</p>
</li>
<li><p>地址变换(地址再定位)：可执行文件生成中的链接技术、程序加载时的重定位技术，进程运行时硬件和软件的地址变换技术和机构。</p>
</li>
<li><p>存储共享和保护：代码和数据共享，对地址空间的访问权限（读、写、执行）。</p>
</li>
<li><p>存储器扩充：它涉及存储器的逻辑组织和物理组织，有两种控制方式：</p>
<ul>
<li><p>由应用程序控制：覆盖；</p>
</li>
<li><p>由OS控制：交换（整个进程空间），请求调入和预调入（部分进程空间）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>地址重定位</p>
<ol>
<li><p>当程序被装入内存时，程序的逻辑地址被转换成内存的物理地址，称为地址重定位。</p>
</li>
<li><p>可执行文件的建立：</p>
<p>​    源程序，编译，成为目标模块（多个目标模块或程序库），链接，成为可执行文件；装入内存，成为进程。</p>
</li>
<li><p>绝对装入</p>
<ul>
<li>只能将可执行文件装入到内存中事先指定好的位置称为绝对装入。</li>
<li>程序的地址再定位是执行之前确定的，在编译，链接时直接制定程序在执行时访问的存储器地址。</li>
</ul>
</li>
<li><p>可重定位装入</p>
<p>1、 在可执行文件中，列出需要重定位的地址单元和相对地址值，装入时在根据锁定位的地址去修改每个重定位的地址值，可装入内存中任何允许的位置。</p>
<p> 2、对地址空间的程序装入物理地址空间时，由于两个空间不一致，需要进行地址变换，即地址的再定位。</p>
<ul>
<li><p>静态再定位</p>
</li>
<li><p>动态再定位</p>
</li>
</ul>
</li>
<li><p>静态再定位</p>
<p>​    静态是指地址定位完成后，在程序的执行期间将不会再发生变化。静态再定位是在程序<strong>执行之前</strong>进行一次性的地址再定位。</p>
<p>​    1、优点 ：无需硬件支持，容易实现，它只要求程序本身是可再定位的，它只对那些要修改的地址部分做出某种标识，地址再定位由专门设计的程序来完成。</p>
<p>​    2、缺点：程序经地址再定位后就不能再移动了，因而不能重新分配内存，不利于内存的有效利用</p>
</li>
<li><p>动态再定位</p>
<p>​    <strong>在程序执行的过程中</strong>，将要访问的程序或者数据的逻辑地址转换成物理地址，即随着指令的执行逐步完成。其实现机制要依赖硬件地址变化机构。主要是基地址寄存器BR，变址寄存器VR。</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E5%86%8D%E5%AE%9A%E4%BD%8D" alt="动态再定位"></p>
<p>​    1、优点：程序在执行期间可以换入和换出内存，可以解决内存紧张；可以在内存中移动，把内存中的碎片集中起来，可以充分利用空间；不必给程序分配连续的内存空间，可以较好的利用较小的内存块；可以实现共享。</p>
<p>​    2、需要附加的硬件支持，实现存储管理的软件算法比较复杂。</p>
</li>
</ol>
</li>
<li><p>存储管理方案</p>
<ol>
<li><p>分区</p>
<p>​    连续存储管理方案，需要一次性全部装入内存，包括固定分区和可变分区两种方案。方法简单，有<strong>内碎片和外碎片</strong>。</p>
</li>
<li><p>页式</p>
<p>​    不连续存储管理方案，需要一次性全部装入内存，逻辑地址空间和物理地址空间<strong>都</strong>采用<strong>分页思想</strong>。<strong>有内碎片</strong>。</p>
</li>
<li><p>段式</p>
<p>​    不连续存储管理方案，需要一次性全部装入内存，逻辑地址空间采用分段式的存储管理，物理地址空间采用<strong>动态分区</strong>的存储管理。有<strong>外碎片</strong>。</p>
</li>
<li><p>段页式</p>
<p>​    逻辑地址空间采用纯分段式的存储管理，物理地址空间采用纯分页式的存储管理。</p>
</li>
<li><p>交换与覆盖技术</p>
<p>​    实现存储扩充，交换技术的优点是编写程序时不需要特殊的控制，也不会影响程序的结构。覆盖技术恰好相反。</p>
</li>
<li><p>虚拟存储</p>
<p>​    分为虚拟页式（请求分页）存储管理和虚拟段式（请求分段）存储管理两种，分别是对纯分页思想和纯分段思想的扩充，都不需要将作业一次性全部装入。实现了存储扩充。</p>
</li>
</ol>
</li>
</ol>
<h2 id="5-2-分区存储管理方案"><a href="#5-2-分区存储管理方案" class="headerlink" title="5.2 分区存储管理方案"></a>5.2 分区存储管理方案</h2><ol>
<li><p>连续分配存储空间，即为一个用户程序分配一个连续的内存空间。</p>
</li>
<li><p>方法——每个占一块</p>
<p>​    把内存分成一些大小相等或不等的分区（partition），每个应用程序占用一个或几个分区，操作系统占用其中一个分区。能够满足多道程序设计，支持多个程序并发执行，可满足分时系统，但难以实现内存分区的共享。</p>
</li>
<li><p>问题——有严重的碎片</p>
<p>​    分为内碎片和外碎片。内碎片是指占用分区之内未被利用的空间；外碎片是指占用分区之间未被利用的空间。</p>
</li>
<li><p>划分</p>
<ol>
<li><p>单一连续分区</p>
<p>​    把整个内存空间的最低端和最高端作为操作系统区，中间作为用户程序区，在DOS中就采用了这种方法。——一个作业也要占用整个内存地址空间</p>
</li>
<li><p>固定分区</p>
<p>​    将内存划分多个<strong>固定大小</strong>的块，以后不可以改变，但是每一个分区不一定一样大，可以不同，以利于不同大小的程序的运行。</p>
<p>​    为了便于管理整个内存，建立一个表格来登记和管理整个内存。在这个表中登记了每一个分区的大小，起始地址和分配状态。当有作业装入时，系统便可以搜索这个表，找出一个大小合适的分区分配给它。当程序运行结束时，可以把它所占用的空间再释放回去。</p>
<p>​    为了实现多道程序设计，可以设置作业等待队列。</p>
<p>​    为了防止程序间的相互干扰以及程序的非法访问，对分区设置<strong>上(下)界寄存器/基址(限长)寄存器</strong>进行保护。</p>
<p>​    1、优点：</p>
<p>​        比单一连续分配方法，内存的利用率提高了；可以支持多道程序；实现简单，开销小。</p>
<p>​    2、缺点：</p>
<p>​        作业必须预先能够估计自己要占用多大的内存空间，有时候这是难以做到的；存在内碎片；分区总数固定，限制了并发执行的程序个数。</p>
</li>
<li><p>可变分区</p>
<ol>
<li><p>基本思想</p>
<p>​    预先并不将内存划分成许多大小不一分区，而是当作业需要时再向系统申请，从其中挖出一块给该作业，然后将剩下的部分再作为空表块，给下一次分配使用。</p>
</li>
<li><p>分区管理使用链表或者线性表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">map</span>&#123;</span></span><br><span class="line">			<span class="keyword">unsigned</span> m_size; <span class="comment">//空闲分区的长度</span></span><br><span class="line">			<span class="keyword">char</span> * m_addr ;   <span class="comment">//空闲分区的起始地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">map</span> <span class="title">cornmap</span>[<span class="title">N</span>];</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>没有内碎片，有外碎片</p>
</li>
<li><p>分区分配算法</p>
<p>​    寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。分区的先后次序通常是从内存低端到高端。</p>
<ol>
<li><p>最先适应算法：</p>
<ol>
<li><p>将所有的空闲分区按照<strong>地址递增</strong>的顺序排列，然后按分区的先后次序，从头查找，找到符合要求的第一个分区。</p>
</li>
<li><p>分配算法</p>
<p>​    当为作业分配大小为size空间时，总是从表的低地址部分查找，当第一次找到大于等于申请大小的空间时，就按所需要的大小分配空间给作业，若分配后还有剩余空间，就修改原来的m_size,m_addr，使得它记录余下的零头；如果作业所需要的空间刚好等于该空间的大小，那么该空间的m_size就为0；然后要删除表中的这些空间，即将各个非零的表项上移。</p>
</li>
<li><p>释放算法</p>
<p>​    当某一个作业释放以前所分配到的内存时，就要将该内存区归还给操作系统，使其成为空闲区而可以被其它作业使用。如果释放区与临近的空闲区相连接，要将它们合并成较大的空闲区，否则空闲区将被分割得越来越小，最终导致不能利用；另外，空闲区个数越来越多，也会使得空闲区登记表溢出。</p>
</li>
<li><p>优点：</p>
<p>​    分配简单而且合并相邻的空闲区也比较容易，该算法的实质是尽可能利用存储区低地址的空闲区，而尽量在高地址部分保存较大的空闲区，以便一旦有分配大的空闲区的要求时，容易得到满足。</p>
</li>
<li><p>缺点</p>
<p>​    由于查找总是从表首开始，前面的空闲区被分割的很小时，能满足分配要求的可能性较小，查找次数就较多。系统中作业越多，这个问题就越严重。</p>
</li>
</ol>
</li>
<li><p>下次适应算法（next-fit，循环最先适应算法）</p>
<ol>
<li>按分区的先后次序，从上次分配的分区起查找,到最后分区时再回到开头，找到符合要求的第一个分区</li>
<li>该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大的空闲分区不易保留。</li>
<li>把空闲表设计成顺序结构或者链接结构的循环队列，各个空闲区仍旧按地址由低到高的次序登记在空闲区的管理队列中，同时需要设置一个<strong>起始查找指针</strong>，指向循环队列中的一个空闲区表项。</li>
<li>循环最先适应算法分配时总是从起始查找指针所指向的表项开始，第一次找到满足要求的空闲区时，就分配所需要的空闲区，然后修改表项，并调整起始查找指针，使其指向队列中被分配的后面的那块空闲区。</li>
<li>循环最先适应算法的实质是起始查找指针所指的空闲区和其后的空闲区群常为较长时间未被分割过的空闲区，它们已经合并成为大的空闲区的可能性较大，比最先适应算法，在没有增加多少代价的情况下却明显的提高了分配查找的速度。</li>
<li>释放算法基本同最先适应算法相同。</li>
</ol>
</li>
<li><p>最佳适应法（best-fit）</p>
<ol>
<li>将空闲分区按<strong>容量递增顺序</strong>排序，从小到大找到其大小与要求<strong>相差最小</strong>的空闲分区。即在所有大于或者等于要求分配长度的空闲区中挑选一个最小的分区，即对该分区所要求分配的大小来说，是最合适的。分配后，所剩余的块会最小。</li>
<li>从个别来看，外碎片较小，但从整体来看，会形成<strong>较多外碎片</strong>。较大的空闲分区可以被保留。</li>
<li>选择的都是适用分区中的最小分区，剩余空白块很小；平均查找一半就能找到最适用块；如果空白区容量正好满足，必被选中。</li>
<li>按大小而非地址排列空闲块，释放时，要在整个链表上搜索地址相邻的空闲区，合并后，又要插入到合适的位置；空白区一般不能恰好满足要求，这样分配后剩余部分会小到无法利用。</li>
</ol>
</li>
<li><p>最坏适应法——找到最大的空闲分区</p>
<ol>
<li><p>思想：将空闲分区按<strong>容量递减顺序</strong>排序，取最前面所有空闲区中最大的一块，把剩余的块再变成一个新的小一点的空闲区。</p>
</li>
<li><p>基本不留下小空闲分区，但较大的空闲分区不被保留。</p>
</li>
<li><p>优点：分配的时候，只需查找一次，就可以成功，分配的算法很快。</p>
<p>缺点：最后剩余的分区会越来越小，无法运行大程序。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>优点：</p>
<ol>
<li><p>实现了主存的共享，因而有助于多道程序设计，更有效地利用了处理机和I/O设备，从而使系统的吞吐量和作业周转时间得到了相应的改善。至于主存利用率，可变式分区比固定分区高些，可再定位式分配则更高些。</p>
</li>
<li><p>相对于后面介绍的存储管理方式，本方案为实现分区分配所使用的表格，占用的存储容量相对较少，算法也相对简单。</p>
</li>
<li><p>实现存储保护的措施也比较简单。</p>
<p>多重分区分配方案能实现对子程序、数据段的共享。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="5-3-页式存储管理"><a href="#5-3-页式存储管理" class="headerlink" title="5.3 页式存储管理"></a>5.3 页式存储管理</h2><h3 id="5-3-1-概述"><a href="#5-3-1-概述" class="headerlink" title="5.3.1 概述"></a>5.3.1 概述</h3><ol>
<li><p>思想</p>
<p>​    将作业<strong>划分成较小的单位</strong>，这些单位可以分散的驻留在内存的“碎片”中，可以解决作业连续存储时，各空闲分区较小，大作业不能装入的问题，即使内存中所有空闲分区之和能够存储该作业。</p>
<p>​    进程在内存中<strong>不一定连续分配</strong>，但需一次全部装入。</p>
</li>
<li><p>基本原理</p>
<p>​    把作业的虚拟地址空间划分成若干个<strong>长度相等</strong>的页（Pages），称为“虚页”，每一个程序的虚页都从0开始编号。主存也划分成若干个与虚页长度相等的块（frame），称为实页。</p>
<p>​    在静态页式存储管理系统中，要求一个作业在运行前将其所有的虚页全部都装入主存的块中，当然这就要求主存中有足够多的空闲块，否则程序便不能运行。</p>
<p>​    <img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A81" alt="页式存储1"></p>
<p>​    分页系统中，页的大小通常都是2的整数次幂，地址的机构由两部分组成，<strong>P(页号)</strong>和<strong>D(页内偏移量)</strong>。访问内存时，分页系统利用页表(记录虚页到实页的对应关系)进行地址变换，过程如下图所示。</p>
<p>​    <img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A82" alt="页式存储2"></p>
</li>
</ol>
<h3 id="5-3-2-页表存储管理"><a href="#5-3-2-页表存储管理" class="headerlink" title="5.3.2 页表存储管理"></a>5.3.2 页表存储管理</h3><ol>
<li><p>页表管理的数据结构</p>
<p>​    进程页表（page table）：记录一个程序在内存中的分布情况。每个进程有一个页表，描述该进程占用的物理页面及逻辑排列顺序；</p>
<p>​    内存页表 (frame table，物理页面表)：整个系统有一个物理页面表，描述物理内存空间的分配使用状况。</p>
<p>​    请求表：整个系统有一个请求表，描述系统内各个进程页表的位置和大小，用于地址转换，也可以结合到各进程的PCB里；</p>
</li>
<li><p>页面变换过程</p>
<p>​    先要得到进程所需要的页面数N，参照内存页表，看是否有这么多的空闲页，如果有，则将N个页面分配给这个进程，并修改内存页表，将程序一次性全部装入用户区内存，同时建立起这个进程的进程页表，也就是页面变换表。如果没有N个空闲页面，则被拒绝或者排队等待。</p>
<p>​    当一个进程执行完成并退出内存时要撤销进程页表，同时修改内存页表。它的过程是：查找该进程的进程页表，将其中的每一行取出，得到物理内存的页号，然后到内存页表中去搜索，把该页所对应的表项的值修改为空闲，以便后面可以继续使用。</p>
</li>
<li><p>硬件支持</p>
<p>​    页式管理系统中，每次访问数据或指令，至少需要访问<strong>两次内存</strong>，第一次是查找页表，第二次才是真正访问指令或者数据。</p>
<p>​    为了加快速度，可以利用硬件支持，设置一对寄存器：页表基址寄存器、页表长度寄存器，或者采用联想存储器。</p>
<ol>
<li><p>设置页表基址寄存器(PTBR, Page Table Base Register)</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A83" alt="页式存储3"></p>
<ul>
<li>每次进程切换时不用保存和恢复新老进程的整个进程页表，只需保存和恢复PTBR。</li>
<li>对进程页表的访问是直接存取。</li>
<li>用户程序执行时的每次内存访问，都至少访问内存两次，第一次访问进程页表，第二次才是访问此次要访问的页的本身，那么用户程序执行时间将增加一倍。</li>
</ul>
</li>
<li><p>设置页表长度寄存器(PTLR, Page Table Length Register)</p>
<p>​    用来实现存储保护，在页表基址寄存器基础上，设置一个页表长度寄存器，它用来存放当前进程页表的长度。在每次访问内存之前，先检查所取得指令的地址是否超过了进程页表的长度。如果在范围之内，则正常访问内存；否则，拒绝此次访问。</p>
</li>
<li><p>联想存储器-快表</p>
<p>​    为了缩短页表查找时间，可以将页表装入到联想存储器(TLB,Translation Lookaside Buffer)，用来存放当前运行作业的页表表项，该存储器是介于内存与寄存器之间的存储机制。</p>
<p>​    很多页式系统都有一组联想存储器，用来存放当前运行作业的页表表项，以加速地址变换过程，这种页表称之为快表，主存中的页表有时也称为慢表。</p>
<p>​     联想存储器可以按内容并行查找，访问速度较之内存快得多，但价格昂贵，所以容量不大。</p>
<p>​    在进行地址变换时，变换机构根据虚拟地址字中页号同时查找快表和慢表，如果在快表中查找到虚页号，就用输出的页面号和虚拟地址字中的偏移地址构造主存物理地址；否则，就用慢表中查到的页号构造物理地址，同时用慢表中的该表项更新快表。</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A84" alt="页式存储"></p>
</li>
</ol>
</li>
</ol>
<h3 id="5-3-3-总结"><a href="#5-3-3-总结" class="headerlink" title="5.3.3 总结"></a>5.3.3 总结</h3><ol>
<li><p>优点</p>
<p>没有外碎片，每个内碎片不超过页大小。</p>
<p>一个程序不必连续存放，便于改变程序占用空间的大小。</p>
</li>
<li><p>缺点</p>
<p>程序全部装入内存</p>
<p>采用动态地址变换机构会增加计算机的成本和降低处理机的速度</p>
<p>各种表格要占用一定的内存空间，而且要花费一定的时间来建立和管理这些表格</p>
</li>
</ol>
<h2 id="5-4-段式存储管理"><a href="#5-4-段式存储管理" class="headerlink" title="5.4 段式存储管理"></a>5.4 段式存储管理</h2><h3 id="5-4-1-段式存储管理"><a href="#5-4-1-段式存储管理" class="headerlink" title="5.4.1 段式存储管理"></a>5.4.1 段式存储管理</h3><ol>
<li><p>引入思想</p>
<ol>
<li><p>方便编程</p>
<p>   ​    通常，一个作业是由若干个自然段组成。因而，用户希望能把自己的作业按照逻辑关系划分为若干个段，每个段都有自己的名字和长度。要访问的逻辑地址是由<strong>段名(段号)和段内偏移量(段内地址)</strong>决定的，每个段都从0开始编址。这样，用户程序在执行中可用段名和段内地址进行访问。</p>
</li>
<li><p>分段共享</p>
<p>​    通常，在实现程序和数据的共享时，都是以信息的逻辑单位为基础的，比如，共享某个例程和函数。而在分页系统中的每一页都只是存放信息的物理单位，其本身并无完整的意义，因而不便于实现信息共享；然而段却是信息的逻辑单位。由此可知，为了实现段的共享，也希望存储管理能与用户程序分段的组织方式相适应。</p>
</li>
<li><p>分段保护</p>
<pre><code>​    在多道程序环境下，为了防止其它程序对某程序在内存中的数据有意无意的破坏，必须采取保护措施。对内存中信息的保护，同样是对信息的逻辑单位进行保护。而且，段作为一个逻辑实体，可分别存放数组、堆栈，故不同的段可以有不同种类的保护。因此，采用分段的组织和管理方式，对于实现保护功能，将是更有效和方便的。</code></pre></li>
<li><p>动态链接</p>
<p>​    通常，用户源程序经过编译后所形成的若干个目标程序，还须再经过链接形成可执行程序后方能执行。这种在装入时进行的链接称为静态链接。<strong>动态链接</strong>是指在作业之前，并不把几个目标程序段链接起来。作业要运行之前先将主程序所对应的目标程序装入内存并启动运行，当<strong>运行过程中</strong>又需要调用某段时，才将该段(目标程序)调入内存并进行链接。可见，动态链接也要求以段作为管理的单位。</p>
</li>
</ol>
</li>
<li><p>基本思想</p>
<ol>
<li><p>在页式的存储管理思想中，作业的地址空间是连续的一维地址空间，程序的各个目标模块都由链接程序装配成一个可执行的程序后装入内存执行。</p>
<p>段式存储管理思想是根据程序的模块结构，把作业地址空间划分为大小不同的一些块，把这些大小不同的块叫做<strong>段</strong>。每段有一个段名，段号(S)从0开始，每一段内也从0连续编址(偏移W)，通常分为主程序段，子程序段，库函数段，数据段等等。<em>同时在物理内存中，也分成一些和这些块一样大的块。</em></p>
<p>作业必须一次性全部装入。</p>
</li>
<li><p>将程序的地址空间划分为若干个段(segment)，程序加载时，分配其所需的所有段（内存分区），这些段不必连续；物理内存的管理采用动态分区。需要CPU的硬件支持。</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AE%B5%E5%BC%8F1" alt="段式1"></p>
</li>
</ol>
</li>
</ol>
<h3 id="5-4-2-具体"><a href="#5-4-2-具体" class="headerlink" title="5.4.2 具体"></a>5.4.2 具体</h3><ol>
<li><p>段式管理的数据结构</p>
<ol>
<li>进程段表：描述组成进程地址空间的各段，可以是指向系统段表中表项的索引。每段有段基址(base address)</li>
<li>系统段表：系统内所有占用段</li>
<li>空闲段表：内存中所有空闲段，可以结合到系统段表中。内存分配算法可以采用最先适应算法、最佳适应算法和最坏适应算法。</li>
</ol>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AE%B5%E5%BC%8F2" alt="段式2"></p>
</li>
<li><p>当段表放在内存中时，每次访问一个数据或者指令的时候，也要访问内存两次</p>
</li>
</ol>
<h3 id="5-4-3-总结"><a href="#5-4-3-总结" class="headerlink" title="5.4.3 总结"></a>5.4.3 总结</h3><ol>
<li><p>优缺点</p>
<ol>
<li><p>段式管理的优点</p>
<p>没有内碎片，外碎片可以通过内存紧缩来消除。便于改变进程占用空间的大小</p>
</li>
<li><p>段式管理的缺点</p>
<p> 进程全部装入内存，不能实现存储扩充。</p>
</li>
</ol>
</li>
<li><p>段与页的比较</p>
<ol>
<li>分页是出于系统管理的需要，分段是出于用户应用的需要。因此，一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。</li>
<li>页大小是系统固定的，而段大小则通常不固定。</li>
<li>逻辑地址表示：分页是一维的，各个模块在链接时必须组织成同一个地址空间；而分段是二维的，各个模块在链接时可以每个段组织成一个地址空间。</li>
<li>通常段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。</li>
<li>段式管理可以实现内存共享，而页式管理不能。二者都不能实现存储扩充。</li>
</ol>
</li>
</ol>
<h2 id="5-5-段页式存储管理"><a href="#5-5-段页式存储管理" class="headerlink" title="5.5 段页式存储管理"></a>5.5 段页式存储管理</h2><h3 id="5-5-1-概述"><a href="#5-5-1-概述" class="headerlink" title="5.5.1 概述"></a>5.5.1 概述</h3><ol>
<li><p>引入</p>
<p>​    分页存储管理能有效地提高内存的利用率，而分段存储管理则能很好地满足用户需要。将两种存储管理方式“各取所长”——段页式</p>
<p>​    段页式存储管理既具有分段系统便于实现、分段可共享、易于保护、可动态链接等优点；又能像分页系统那样很好地解决内存的外碎片问题，以及为各个分段可不连续地分配内存等问题。这种方式显然是一种比较有效的存储管理方式。</p>
</li>
</ol>
<h3 id="5-5-2-基本"><a href="#5-5-2-基本" class="headerlink" title="5.5.2 基本"></a>5.5.2 基本</h3><ol>
<li><p>基本思想</p>
<p>1、对用户程序分段，内存中按页表来存储进行</p>
<p>2、段页式存储管理是对纯页式和纯段式存储管理的结合：将用户程序分为若干各段，<em>再把每个段划分成若干个页</em>，并为每一个段赋予一个段名。也就是说将用户程序按段式划分，而将物理内存按页式划分，即以页为单位进行分配。换句话来说，对用户来讲是按段的逻辑关系进行划分，而对系统来讲是按页划分每一段。</p>
<p>3、在段页式存储管理中，其地址结构由段号、段内页号和页内地址三部分组成</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AE%B5%E9%A1%B51" alt="段页1"></p>
<p>4、在段页式存储管理中，为了实现从逻辑地址到物理地址的变换，系统中需要同时配置段表和页表。由于允许将一个段中的页进行不连续分配，因而使段表的内容有所变化：它不再是段内起始地址和段长，而是页表起始地址和页表长度。</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AE%B5%E9%A1%B52" alt="段页2"></p>
<p>5、段页式存储管理的数据结构</p>
<p>​    段表：记录了每一段的页表起始地址和页表长度。</p>
<p>​    页表：记录了每一个段所对应的逻辑页号与内存块号的对应关系，每一段有一个页表，而一个程序可能有多个页表。</p>
<p>​    空闲内存页表：由于物理内存采用分页式的存储管理，所以它的结构同分页式存储管理。</p>
<p>​    物理内存分配：同分页式存储管理。</p>
</li>
<li><p>地址变换</p>
<p>​    在段页式系统中，配置一个段表基址寄存器，在其中存放段表起始地址；一个段表长度寄存器，在其中存放段长SL。进行地址变换时，首先利用段号S，将它与段长SL进行比较。若S&lt;SL，表示没有越界，于是利用段表起始地址和段号求出该段对应的段表项在段表中的位置，从中得到该段的页表起始地址，并利用逻辑地址中的段内页号P来获得对应的页表项位置，从中读出该页所在的物理块号b，再用块号b和页内地址构成物理地址。 </p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AE%B5%E9%A1%B53" alt="段页3"></p>
</li>
</ol>
<h3 id="5-5-3-总结"><a href="#5-5-3-总结" class="headerlink" title="5.5.3 总结"></a>5.5.3 总结</h3><p>​      在段页式存储管理中，为了获得一条指令或数据，需三次访问内存：</p>
<ul>
<li><p>第一次访问内存中的段表，获得页表地址；</p>
</li>
<li><p>第二次访问内存中的页表，获得该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；</p>
</li>
<li><p>第三次访问才是真正根据所得的物理地址取出指令或者数据。</p>
</li>
</ul>
<p>​     显然，速度下降很多，于是在地址变换机构中引入一个联想存储器（快表或高速缓冲寄存器），每次访问内存时，都是同时利用段号和页号进行检索。</p>
<h2 id="5-6-交换技术与覆盖技术"><a href="#5-6-交换技术与覆盖技术" class="headerlink" title="5.6 交换技术与覆盖技术"></a>5.6 交换技术与覆盖技术</h2><h3 id="5-6-1-概述"><a href="#5-6-1-概述" class="headerlink" title="5.6.1 概述"></a>5.6.1 概述</h3><p>​    在多道程序设计环境下，为了解决并发作业的程序地址空间总和大于内存可用空间而无法运行的问题，引入内存扩充。即借助大容量的辅存在逻辑上实现内存的扩充，来解决内存容量不足的问题。</p>
<p>​    比较常用的有覆盖技术和交换技术。前者主要用于早期的操作系统中，后者广泛用于小型分时系统中，其发展导致了虚拟技术的出现。两者共同之处都是程序和数据主要放在外存，<u>当前需要执行的部分放在内存，内外存之间进行信息交换，不同之处在于如何交换信息。</u></p>
<h3 id="5-6-2覆盖技术"><a href="#5-6-2覆盖技术" class="headerlink" title="5.6.2覆盖技术"></a>5.6.2覆盖技术</h3><p>​    通常一个程序的几个代码段和数据段是按照<strong>时间先后顺序</strong>占用内存的，装入时可以采用如下几种：——存在覆盖顺序</p>
<ul>
<li><p>将程序的必要部分（常用功能）的代码和数据常驻内存；</p>
</li>
<li><p>将可选<strong>部分</strong>（不常用功能）在<u>其它程序模块中实现</u>，平时存放在外存中的<em>覆盖文件</em>中，用到时才装入内存；</p>
</li>
<li><p>不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖。</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF" alt="覆盖技术"></p>
<p>缺点：对用户不透明；执行效率低；有碎片。</p>
</li>
</ul>
<h3 id="5-6-3-交换技术"><a href="#5-6-3-交换技术" class="headerlink" title="5.6.3 交换技术"></a>5.6.3 交换技术</h3><ul>
<li><p>在内存空间紧张时，系统将内存中某些进程暂时移到外存，把外存中某些进程换进内存，占据前者所占用的区域，这种技术是<strong><u>进程</u>在内存和外存之间的动态调度</strong>。</p>
</li>
<li><p>与覆盖技术相比，交换技术不要求给出程序段之间的逻辑覆盖结构；而且，交换发生在进程或作业之间，而覆盖发生在同一进程或作业内。</p>
</li>
<li><p>优点：增加并发执行的程序数目；对程序员透明。</p>
</li>
<li><p>缺点：增加处理机开销；程序整个地址空间都进行交换，信息量特别大；程序换入时需要重定位。</p>
</li>
</ul>
<h2 id="5-7-虚拟存储"><a href="#5-7-虚拟存储" class="headerlink" title="5.7 虚拟存储"></a>5.7 虚拟存储</h2><h3 id="5-7-1-概述"><a href="#5-7-1-概述" class="headerlink" title="5.7.1 概述"></a>5.7.1 概述</h3><ol>
<li><p>局部性原理</p>
<p>​    指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域，可以表现为：</p>
<ul>
<li><p>时间局部性，即一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内；</p>
</li>
<li><p>空间局部性，即当前指令和邻近的几条指令，当前访问的数据和邻近的数据都集中在一个较小区域内。</p>
</li>
</ul>
<p>具体体现：</p>
<ul>
<li>程序在执行时，大部分是顺序执行的指令，少部分是转移和过程调用指令。</li>
<li>过程调用的嵌套深度一般不超过5，因此执行的范围不超过这组嵌套的过程。</li>
<li>程序中存在相当多的循环结构，它们由少量指令组成，而被多次执行。</li>
<li>程序中存在相当多对一定数据结构的操作，如数组操作，往往局限在较小范围内。</li>
</ul>
</li>
<li><p>基本原理</p>
<ol>
<li>在程序装入时，不必将其全部读入到内存，而只需将当前需要执行的<strong>部分页或段</strong>读入到内存，就可让程序开始执行。</li>
<li>在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页或段调入到内存，然后继续执行程序。</li>
<li>另一方面，操作系统将内存中暂时不使用的页或段调出保存在外存上，从而腾出空间存放将要装入的程序以及将要调入的页或段―具有请求调入和置换功能，只需程序的一部分在内存就可执行，对于动态链接库也可以请求调入</li>
</ol>
</li>
<li><p>好处</p>
<ol>
<li>可在较小的可用内存中执行较大的用户程序；</li>
<li>可在内存中容纳更多程序并发执行；</li>
<li>不必影响编程时的程序结构（与覆盖技术比较）</li>
<li>提供给用户可用的虚拟内存空间通常大于物理内存(real memory)</li>
</ol>
</li>
<li><p>特征</p>
<ol>
<li>物理内存分配的不连续性，虚拟地址空间使用的不连续性（数据段和栈段之间的空闲空间，共享段和动态链接库占用的空间）</li>
<li>与交换的比较：调入和调出是对部分虚拟地址空间进行</li>
<li>通过物理内存和快速外存相结合，提供大范围的虚拟地址空间，但占用容量不超过物理内存和外存交换区容量之和，其中占用容量包括：进程地址空间中的各个段，操作系统代码</li>
</ol>
</li>
<li><p>种类</p>
<ol>
<li>虚拟页式（请求分页）：在简单页式存储管理的基础上，增加请求调页和页面置换功能。</li>
<li>虚拟段式（请求分段）：在简单段式存储管理的基础上，增加请求调段和段置换功能。</li>
<li>虚拟段页式（请求段页式）：请求分页和请求分段的结合。</li>
</ol>
</li>
</ol>
<h3 id="5-7-2-虚拟页式"><a href="#5-7-2-虚拟页式" class="headerlink" title="5.7.2 虚拟页式"></a>5.7.2 虚拟页式</h3><ol>
<li><p>基本思想</p>
<p>​    分页存储管理方法，必须一次性将所有的页面全部装入，有可能造成其他的作业无法装入，从而造成系统的性能下降。</p>
<p>​    因此，要想办法使得程序在装入时，不一次性装入，只要装入当前运行需要的一部分页面即可，称这些页面为”工作集”。</p>
</li>
<li><p>调页——缺页中断；装入——页面调度</p>
</li>
<li><p>页表</p>
<ol>
<li><p>页表表项</p>
<p>使用扩充的进程页表和系统页表，需要在进程页表中添加若干项</p>
<ul>
<li><p>存在位：该页是否已调入物理内存</p>
</li>
<li><p>修改位(modified bit)：该页调入内存后是否被修改过</p>
</li>
<li><p>访问统计：在近期内被访问的次数，或最近一次访问到现在的时间间隔</p>
</li>
<li><p>外存地址(disk address)：该页在外存上的地址</p>
</li>
</ul>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F1" alt="虚拟1"></p>
</li>
<li><p>细节说明</p>
<ul>
<li><p>将某一页从内存移到外存称为“出页”，从外存调入内存称为“入页”，入页与出页的操作称为“分页”操作。</p>
</li>
<li><p>在请求分页系统中，从内存中刚刚移走某个页面后，根据请求马上又调入该页．这种反复进行入页和出页的现象称为“抖动”，也叫做系统颠簸。它浪费了大量的处理机时间，所以应尽可能避免“抖动”的发生。</p>
</li>
</ul>
</li>
<li><p>缺页中断</p>
<p>​    由CPU的地址变换机构根据页表中的存在位判断是否产生缺页中断，然后调用操作系统提供的中断处理程序。缺页中断的特殊性：</p>
<ul>
<li><p>缺页中断在<strong>指令执行期间产生和进行处理</strong>，而不是在一条指令执行完毕之后。所缺的页面调入之后，重新执行被中断的指令。</p>
</li>
<li><p>一条指令的执行可能产生多次缺页中断。</p>
</li>
</ul>
</li>
<li><p>页面调度策略</p>
<ol>
<li><p>页面调入策略：决定什么时候将一个页从外存调入物理内存；</p>
<ul>
<li>请求调页(demand paging)：只调入发生缺页时所需的页面。</li>
<li>预调页(prepaging)：在发生缺页需要调入某页时，一次调入该页以及相邻的几个页。</li>
</ul>
</li>
<li><p>置页策略：决定调入的虚页在物理内存的最佳位置；</p>
</li>
<li><p>页面置换策略：在内存已满时决定将哪个虚页从内存中移出。</p>
<ol>
<li><p>FIFO算法：</p>
<ul>
<li>选择建立最早的页面被置换。可以通过链表来表示各页建立时间的先后。性能较差。较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出</li>
<li>FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，即被置换的页面并不是进程<strong>不会</strong>访问的。</li>
</ul>
</li>
<li><p>最久未使用算法（LRU, Least Recently Used）</p>
<p>​    选择内存中最久未使用的页面被置换。这是局部性原理的合理近似，性能接近最佳算法。但由于需要记录页面使用时间的先后关系，硬件开销太大。硬件机构可以为：</p>
<ul>
<li>一个特殊的栈：把被访问的页面移到栈顶，于是栈底的是最久未使用页面。</li>
<li>每个页面设立移位寄存器（通常是64位，作为计数器）：被访问时左边最高位置1，定期右移并且最高位补0，于是寄存器数值最小的是最久未使用页面。</li>
</ul>
</li>
<li><p>LRU的软件解决方案：</p>
<ol>
<li><p>最不经常使用（NFU, Not Frequently Used)</p>
<p>​    淘汰访问次数最少的页面：每页设置一个软件计数器，初值为0。每次时钟中断时，由操作系统对内存中的页进行扫描，把每个页的计数器加R（0或1）。这样，计数器跟踪各个页被访问的频繁程度，发生缺页中断时，选择计数器值最小的一页淘汰。</p>
</li>
<li><p>最近未使用算法(NRU, Not Recently Used)</p>
<ul>
<li><p>每页设置一个标志位(bit),若该页被访问， bit＝1</p>
</li>
<li><p>置换时采用一个指针，从当前位置开始查找，寻找bit＝0的页面置换</p>
</li>
<li><p>指针经过的也都被修改为bit＝0，最后指针停留在置换页的下一页面。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>缺页率</p>
<p>​    缺页率表示“<strong>缺页次数/内存访问次数</strong>”或“缺页的平均时间间隔”，影响因素包括：</p>
<ul>
<li>分配给进程的物理页面数目：数目越多，缺页率越低。</li>
<li>页面大小：页面很小，每个进程的内存页数目较多，通过调页很快适应局部性原理的要求，缺页率低；页面很大，每个进程使用的大部分地址空间都在内存，缺页率低；页面中等大小，局部性区域只占每页的较小部分，缺页率高。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="5-7-3-虚拟段式"><a href="#5-7-3-虚拟段式" class="headerlink" title="5.7.3 虚拟段式"></a>5.7.3 虚拟段式</h3><ol>
<li>在简单段式存储管理的基础上，增加请求调段和段置换功能。</li>
<li>地址变换和缺段中断：指令和操作数必定不会跨越在段边界上。</li>
</ol>
<h2 id="5-8-高速缓冲存储器"><a href="#5-8-高速缓冲存储器" class="headerlink" title="5.8 高速缓冲存储器"></a>5.8 高速缓冲存储器</h2><p>​    高速缓存是为了匹配CPU的处理速度与内存的访问速度而增加的高速存储器，其目标是提高CPU的利用率。</p>
<p><img src="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98" alt="高速缓存"></p>
<ol>
<li><p>缓冲存储器</p>
<p>用作缓存内存中数据</p>
</li>
<li><p>缓冲目录：</p>
<p>​    描述各缓冲存储器块的状态。缓冲目录的表项与缓冲存储器块一一对应。它包括内存地址行号、状态位，以及用于缓存淘汰算法的缓存访问信息。</p>
</li>
<li><p>缓存控制器：</p>
<p>​    负责缓存目录的维护，并利用缓存淘汰算法进行缓存的更新。</p>
</li>
<li><p>缓存的工作过程</p>
<p>​    在不同类型的内存操作时，缓存会有不同的工作过程。具体的缓存工作过程包括以下几个方面：</p>
<ul>
<li>CPU读数据</li>
<li>CPU写数据</li>
<li>通道向内存写数据</li>
<li>通道从内存读数据</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="ckaalq0ka0004v0l55wjtchks" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SomeProblemSolution" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/27/SomeProblemSolution/" class="article-date">
  <time datetime="2020-03-27T14:29:30.000Z" itemprop="datePublished">2020-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/27/SomeProblemSolution/">Some Problems &amp; Solutions</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、-Java环境配置"><a href="#一、-Java环境配置" class="headerlink" title="一、 Java环境配置"></a>一、 Java环境配置</h1><h3 id="1-JDK的下载"><a href="#1-JDK的下载" class="headerlink" title="1. JDK的下载"></a>1. JDK的下载</h3><ol>
<li>由于我们安装的Eclipse是由Java写的，所以我们在下载Eclipse之前需要下载Java环境，即JDK或者JRE。<ol start="2">
<li>在Oracle的官网进行JDK的下载速度会比较慢，有以下几种方法加速  <ul>
<li>将下载链接去掉https，因为下载时默认使用https，慢</li>
<li>使用下载工具， 百度，迅雷等</li>
<li>国内各大公司的镜像站，如<a href="https://repo.huaweicloud.com/java/jdk/" target="_blank" rel="noopener">华为</a>,快到起飞</li>
<li>挂代理</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2. 配置环境变量"></a>2. 配置环境变量</h3><ol>
<li><p>在系统变量中设置2(或3)项属性，JAVA_HOME、PATH(、CLASSPATH),在使用1.5以上版本的JDK，不用设置CLASSPATH环境变量，也可以正常编译和运行JAVA程序</p>
</li>
<li><p>变量设置参数如下:    </p>
<ul>
<li><p>变量名:JAVA_HOME</p>
<p>变量值:C:\Program Files (x86)\Java\jdk //因人而异</p>
</li>
<li><p>变量名:CLASSPATH</p>
<p>变量值:.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</p>
</li>
<li><p>变量名:PATH</p>
<p>变量值:%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; //在win10中会须将其去分号,分两条添加</p>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>测试  </p>
<p>cmd中键入Java测试</p>
</li>
</ol>
<h3 id="3-JAVA开发工具"><a href="#3-JAVA开发工具" class="headerlink" title="3. JAVA开发工具"></a>3. JAVA开发工具</h3><ol>
<li>Eclipse下载及安装</li>
</ol>
<h1 id="二、-python常见问题"><a href="#二、-python常见问题" class="headerlink" title="二、 python常见问题"></a>二、 python常见问题</h1><h3 id="1-第三库的引入"><a href="#1-第三库的引入" class="headerlink" title="1. 第三库的引入"></a>1. 第三库的引入</h3><h4 id="1-pip下载"><a href="#1-pip下载" class="headerlink" title="1. pip下载"></a>1. pip下载</h4><p>​    1. pip 更新</p>
<p>​    <code>python -m pip install --upgrade pip</code></p>
<p>​    2. pip临时更换镜像源  </p>
<p>​    <code>pip install pythonModuleName -i https://pypi.douban.com/simple</code></p>
<p>​    3. pip更换镜像源（待续）</p>
<h4 id="2-wheel文件"><a href="#2-wheel文件" class="headerlink" title="2. wheel文件"></a>2. wheel文件</h4><ol>
<li><p>首先安装wheel文件的依赖  </p>
<p><code>pip install wheel</code></p>
</li>
<li><p>在网站上下载对应版本的.whl文件，在<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">网站</a>上下载whl文件</p>
</li>
<li><p>切换到.whl文件所在的路径，键入  </p>
<p><code>pip install Doucumentname.whl</code>  </p>
<p>安装对应的库文件。或者直接键入  </p>
<p><code>pip install path\Documentname.whl</code>  </p>
<p>如果出现红字<strong>not a supported wheel on this platform</strong>表示wheel文件与python版本不符合(cp36表示python3.6)</p>
</li>
</ol>
<h4 id="3-github项目安装"><a href="#3-github项目安装" class="headerlink" title="3. github项目安装"></a>3. github项目安装</h4><p>​    首先在github上clone整个项目，然后打开文件夹找到有setup.py这个文件的目录下，打开powershell/cmd，输入python setup.py install 即可完成安装</p>
<h3 id="2-jupyter-notebook的自定义启动"><a href="#2-jupyter-notebook的自定义启动" class="headerlink" title="2. jupyter notebook的自定义启动"></a>2. jupyter notebook的自定义启动</h3><ol>
<li><p>安装jupyter  </p>
<p><code>pip install jupyter</code></p>
</li>
<li><p>设置notebook的文件存储地址  </p>
<p><code>jupyter notebook --generate-config</code></p>
</li>
<li><p>通过编辑器打开该.py文件，在文件中搜索“c.NotebookApp.notebook_dir”，然后去掉该行前的 <strong>#</strong> 号，在该项上加入你需要的目录地址</p>
</li>
<li><p>然后回到命令终端再次输入：</p>
<p><code>jupyter notebook --generate-config</code><br>这个时候会出现是否要覆盖原来的py配置文件，点y。  </p>
<p><strong>至此，Done！</strong></p>
</li>
</ol>
<h3 id="3-pylint"><a href="#3-pylint" class="headerlink" title="3. pylint"></a>3. pylint</h3><p>​       pylint是一个python代码分析工具，分析python代码中的错误，查找不符合代码风格标准有潜在问题的代码，它还提供了其他的功能，如检查一行代码的长度，变量名是否符合命名标准，一个声明过的接口是否被真正实现等等。  </p>
<p>安装:  <code>pip install pylint</code>  </p>
<p><a href="https://www.jianshu.com/p/c0bd637f706d" target="_blank" rel="noopener">参考网址</a></p>
<h1 id="三、-github-加快git速度"><a href="#三、-github-加快git速度" class="headerlink" title="三、 github 加快git速度"></a>三、 github 加快git速度</h1><h2 id="1-码云平台的转接"><a href="#1-码云平台的转接" class="headerlink" title="1.码云平台的转接"></a>1.码云平台的转接</h2><h3 id="1、从github到码云"><a href="#1、从github到码云" class="headerlink" title="1、从github到码云"></a>1、从github到码云</h3><ol>
<li><p>首先确保码云上有账户，可以正常使用；</p>
</li>
<li><p>点击页面右上角新建仓库的加号 <code>+</code>，选择“从 <code>GitHub/GitLab</code>导入仓库”菜单；</p>
</li>
<li><p>然后填写位于 <code>GitHub</code>上你想 <code>clone</code>的仓库地址并导入；</p>
</li>
<li><p>接下来通过码云上的项目地址，将项目 <code>clone</code>到本地，这时候的clone速度就很快了，几 <code>MB/s</code>的速度是没问题的，很快项目就下载下来了。</p>
</li>
</ol>
<h3 id="2、重新关联远端地址"><a href="#2、重新关联远端地址" class="headerlink" title="2、重新关联远端地址"></a>2、重新关联远端地址</h3><p>要知道，这时候克隆到本地的项目关联的是码云Gitee的地址，已经和原来的GitHub项目<strong>完全脱离了</strong>，是另外一个<strong>副本</strong>。</p>
<p>在必要情况下（比如我们就是要给GitHub上的某个项目提 <code>PR</code>），我们还需要重新将我们本地的项目关联到原来的GitHub项目上去，做法如下：</p>
<ol>
<li><p>首先找到位于本地仓库目录下的隐藏文件<code>.git</code></p>
</li>
<li><p>用文本编辑器打开<code>.git</code>文件夹中的<code>config</code>配置文件，将配置文件中的<code>[remote &quot;origin&quot;].url</code>字段重新关联到原来位于<code>Github</code>上的<code>Github</code>项目的地址。</p>
</li>
</ol>
<p><a href="https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA" target="_blank" rel="noopener">一招搞定GitHub下载加速!</a></p>
<h3 id="3-一些小问题"><a href="#3-一些小问题" class="headerlink" title="3. 一些小问题"></a>3. 一些小问题</h3><p>   在git clone 码云地址的项目时出现<code>Incorrect username or password ( access token )</code>,原因是输入的git账号和密码不是码云的账号密码，更改为码云的账号和密码即可：通过“管理网络密码更改”更改windows保存的gitee账号密码信息即可。</p>
<h2 id="2-待续"><a href="#2-待续" class="headerlink" title="2. 待续"></a>2. 待续</h2><h1 id="四、-Hexo如何显示本地图片"><a href="#四、-Hexo如何显示本地图片" class="headerlink" title="四、 Hexo如何显示本地图片"></a>四、 Hexo如何显示本地图片</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>本地插入的图片可以本地看见，但是部署到云端会不可见</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li>设置站点配置 <code>_config.yml</code>:将<code>post_asset_folder: false</code>改为<code>post_asset_folder: true</code></li>
<li>安装插件：<code>npm install https://github.com/CodeFalling/hexo-asset-image -- save</code></li>
<li>运行<strong><code>hexo n &quot;XXXXXX&quot;</code></strong>,在生成XXXXX.md博文时就会在<code>/source/_posts</code>目录下生成XXXXXX的文件夹，将你想在XXXXX博文中插入的照片放置到这个同名文件夹中即可，图片的命名随意。</li>
<li><strong>添加图片</strong>:在想添加的位置写入<code>![](图片名字.图片格式)</code>,例如<code>![](1.png)</code>。<br><a href="https://blog.csdn.net/Fitz1318/article/details/86548129?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">参考链接</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/27/SomeProblemSolution/" data-id="ckaalq0jr0000v0l57xcn4tfs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%88%91%E7%A2%B0%E8%A7%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/" rel="tag">我碰见的一些小问题</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-InstructionOfHexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/23/InstructionOfHexo/" class="article-date">
  <time datetime="2020-03-23T03:08:28.884Z" itemprop="datePublished">2020-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/23/InstructionOfHexo/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/23/InstructionOfHexo/" data-id="ckaalq0jx0001v0l58pxo9op7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%88%91%E7%A2%B0%E8%A7%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/" rel="tag">我碰见的一些小问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95-%E6%A0%88/" rel="tag">算法,栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E6%88%91%E7%A2%B0%E8%A7%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/" style="font-size: 10px;">我碰见的一些小问题</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E6%A0%88/" style="font-size: 10px;">算法,栈</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" style="font-size: 10px;">计算机</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/11/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a>
          </li>
        
          <li>
            <a href="/2020/05/25/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">LeetCode每日一题</a>
          </li>
        
          <li>
            <a href="/2020/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
          </li>
        
          <li>
            <a href="/2020/03/27/SomeProblemSolution/">Some Problems &amp; Solutions</a>
          </li>
        
          <li>
            <a href="/2020/03/23/InstructionOfHexo/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>